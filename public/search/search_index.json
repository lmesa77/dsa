{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Arquitectura de Servicios de Dominio","text":""},{"location":"index.html#contexto","title":"Contexto","text":"<p>Ante la necesidad de migrar los servicios restantes que conviven en el modelo de Framework, se abre el debate sobre el proceso de implementaci\u00f3n de los mismos del lado del modelo de Dominio present\u00e1ndose tres caminos:</p> <ul> <li>Migraci\u00f3n como se ha estado llevando hasta hoy.</li> <li>Refactorizaci\u00f3n del modelo de Dominio.</li> <li>Proponer una evoluci\u00f3n del modelo de Dominio, aplicando buenas pr\u00e1cticas de la industria del desarrollo de software. (Dominio 2.0)</li> </ul> <p>Este \u00faltimo camino coge fuerza dada la oportunidad de implementar una arquitectura orientada a Microservicios que provea al conjunto de componentes miembros una operatividad desacoplada, reusable, mantenible y orientada a la configuraci\u00f3n.</p>"},{"location":"index.html#generalidad","title":"Generalidad","text":"Diagrama de alto nivel <p>Objetivo: Una arquitectura de capas basado en Microservicios donde se promuevan unos lineamientos de desarrollo y cultura que al ser observados en los proyectos a futuro, promueven la modularizaci\u00f3n de los servicios enfoc\u00e1ndose en la responsabilidad \u00fanica, comunicaci\u00f3n agn\u00f3stica y buenas practicas en el desarrollo. (Sistemas tipo LEGO).</p>"},{"location":"index.html#definicion","title":"Definici\u00f3n","text":"<p>La Arquitectura de servicios de dominio (ASD) es una agrupaci\u00f3n de componentes basada en el patr\u00f3n de microservicios y que en su conjunto atienden distintas operaciones especiales derivadas de la venta del sistema POS. Cada uno de estos componentes tiene una funci\u00f3n definida y estructurada con el fin de hacerlos:</p> <ul> <li>Escalables</li> <li>Mantenibles</li> <li>Reutilizables</li> <li>Desacoplados</li> <li>Cohesivos</li> </ul>"},{"location":"index.html#servicios-componentes-y-adaptadores","title":"Servicios, Componentes y Adaptadores","text":"<p>Son las unidades de software b\u00e1sicas en que se compone la ASD. Sus definiciones en el contexto de esta arquitectura son:</p> <ul> <li> <p>Servicios: Son todas aquellas piezas de software desplegadas e instanciadas sobre un servidor de aplicaciones u otro mecanismo y que est\u00e1n a la escucha de peticiones para realizar una tarea especifica sin importar quien lo invoque.</p> </li> <li> <p>Componentes: Son todas aquellas unidades funcionales propias que se integran directamente dentro de otra aplicaci\u00f3n y se ejecutan en el mismo contexto.</p> </li> <li> <p>Adaptadores: Son todas aquellas piezas de software que act\u00faan como un intermediario entre dos tecnolog\u00edas, permitiendo que sistemas o componentes propios y de terceros trabajen juntos sin acoplarse.</p> </li> </ul>"},{"location":"index.html#capas-de-la-arquitectura-de-servicios-de-dominio","title":"Capas de la Arquitectura de Servicios de Dominio","text":"<p>La ASD se divide b\u00e1sicamente en dos capas: la primera atiende la operaci\u00f3n del lado de la terminal y son componentes que por su vocaci\u00f3n deben operar lo mas cerca posible del sistema POS y de la misma terminal. La segunda capa es el conjunto de componentes que se enfocan en proveer una funcionalidad a varias terminales cliente y que pueden ser desplegados en sistemas distribuidos.</p>"},{"location":"index.html#capa-de-terminal","title":"Capa de Terminal","text":"<p>En esta capa encontramos los siguientes piezas de software:</p> <ul> <li> <p>Terminal Gateway Service: Su tarea es recibir y redireccionar las peticiones que lleguen desde el sistema POS cliente y entregar al mismo el resultado de la operaci\u00f3n.</p> </li> <li> <p>Data Collector Service: Su tarea es recolectar y validar la informaci\u00f3n fuente para el procesamiento de la operaci\u00f3n. Recibe una petici\u00f3n y mediante una configuraci\u00f3n definida para la operaci\u00f3n a procesar, realiza la validaci\u00f3n de data ademas de buscar la informaci\u00f3n complementaria que no sea entregada en la petici\u00f3n del POS cliente.</p> </li> <li> <p>Parameter Local Storage Service: Su tarea es proveer de manera local las configuraciones definidas para el procesamiento de los datos que se usan en una operaci\u00f3n.</p> </li> <li> <p>Java-Basic Adapter (JBAdapter): Es un servicio que cumple la tarea de \"adaptar\" la comunicaci\u00f3n bidireccional entre el POS cliente y la ASD. Recibe la petici\u00f3n del lado del POS, traduce la petici\u00f3n entrante a la estructura esperada en la API del Terminal Gateway Service y realiza el mismo proceso en la respuesta que entregue la ASD.</p> </li> <li> <p>Toshiba Adapter: Este adaptador es un componente expone una serie de funcionalidades propias del POS que son utilizadas del lado de la ASD sin acoplar la arquitectura a esta tecnolog\u00eda concreta. Provee por ejemplo interacci\u00f3n con la capa del frontend y recuperaci\u00f3n de datos que tiene como fuente el sistema POS.</p> </li> </ul>"},{"location":"index.html#capa-de-servicios","title":"Capa de Servicios","text":""},{"location":"apuntes.html","title":"Apuntes","text":""},{"location":"apuntes.html#reponsables","title":"Reponsables","text":"<ul> <li>John Fredy Marulanda Correa (jmarulanda@grupo-exito.com)</li> <li>Guiovanni Gualteros (ggualteros@grupo-exito.com)</li> </ul>"},{"location":"apuntes.html#apoyo-tecnico","title":"Apoyo t\u00e9cnico","text":"<ul> <li>Jose Bernardo Arcos</li> <li>Duv\u00e1n Agudelo</li> </ul>"},{"location":"apuntes.html#contexto","title":"Contexto","text":"<p>Ventas de Contenido es un canal por el cual se venden servicios de terceros tales como telefonia, streaming y membresias entre otras. El proceso consiste en indicarle al POS el PLU asociado al servicio (representado en tarjetas):</p> Tarjetas de Membres\u00eda C\u00f3digo de barras de la tarjeta <p>Seguidamente se escanea el c\u00f3digo de barras de la tarjeta (1). En la mayoria de casos, las tarjetas cuentan con un valor asignado de recarga (2) con excepcion de algunas tarjetas de telefonia que si permiten agregar un valor de recarga indefinido.</p> <p>El POS envia la informacion al autorizador y este puede responder:</p> <ol> <li> <p>Aceptando la intenci\u00f3n de activaci\u00f3n: En caso de aceptaci\u00f3n, el servicio no queda recargado hasta que no se confirma el pago de la tarjeta.<sup>(revisar)</sup> Este pago se puede realizar por cualquier tipo de medio dispuesto para ello.</p> </li> <li> <p>Rechazando la intencion de activaci\u00f3n: En caso de rechazo, el POS muestra un mensaje gen\u00e9rico de rechazo.<sup>(revisar)"},{"location":"apuntes.html#componentes","title":"Componentes","text":"<ul> <li> <p>Archivo JAR: <code>VentaContenidos.jar</code></p> </li> <li> <p>Archivo HCH: <code>HCHCONTE.JAR</code></p> </li> <li> <p>Dependencia: <code>FrameworkContenidosPagos.jar</code></p> </li> <li> <p>Archivo FW: <code>FWVDCONT.DAT</code></p> </li> <li> <p>Archivo BAS: <code>uefrwmod</code>, <code>uefrwmo2</code>, <code>uefrmo3</code></p> </li> </ul>"},{"location":"apuntes.html#preguntas","title":"Preguntas","text":"<ul> <li> Diferencia entre FW y Dominio</li> <li>Implementacion de soluciones que escalan la funcionalidad del POS</li> <li> Dominio: Es escalable y permite la integreacion de varias soluciones<ul> <li>Persistencia manejada con BBDD</li> <li>Comunicacion de comunicaciones propias (Servidor de Aplicaciones)</li> </ul> </li> <li> Framework: Enfocada en un tipo de soluciones especificas... no permitia la escalabilidad por su complejidad.<ul> <li>Venta: Es la venta de un PLU. Lon ingreso proviene del ejercicio del negocio.</li> <li>Pago: Es el movimiento de dinero en ambas direcciones que pueden tener o no relacionados un PLU. Los ingresos se dan por el movimiento de dinero.</li> <li>Operaci\u00f3n No Venta: Operaciones que no generan ingresos.</li> <li>Persistencia acoplado a TOSHIBA (Archivos KEYED)</li> <li>Comunicaci\u00f3n mediante PAF</li> </ul> </li> <li> \u00bfCual es la filosofia en la migraci\u00f3n... que se pretende mejorar?</li> <li>Escalabilidad</li> <li>Persistencia</li> <li>Comunicaci\u00f3n</li> <li>Mantenibilidad</li> <li> \u00bfHan habido intentos anteriores de migraci\u00f3n y si ha sido asi en que han fallado?</li> <li>Ya se han migrado servicios de manera completa</li> <li>Otras aun existen en Framework por falta de tiempo/recursos</li> <li>Tarjetas Regalo y Convenios existen en ambas arquitecturas (hibrido)</li> <li> \u00bfHay lineamientos en la migracion actualmente?</li> <li>Que tipo de producto se desea migrar (reglas de negocio)</li> <li> <p> \u00bfHomologos de componentes entre arquitecturas (Ej HCH's)?</p> </li> <li> <p> \u00bfHay m\u00f3dulo de activaci\u00f3n? - \u00bfSe permite reversar la compra despues del pago? <li> \u00bfCuales son los servicios que se venden en los puestos de pago?</li> <li>Netflix</li> <li>PSStore</li> <li>Xbox</li> <li>Recarga a operadores de telefonia (distintos a Movil Exito)</li> <li> \u00bfLos atributos de configuracion se deben externalizar? (por fuera de la compilaci\u00f3n) <li> \u00bfQu\u00e9 componente de BASIC empuja la ejecuci\u00f3n de ventaContenido?</li> <li><code>uefrwmod</code></li> <li><code>uefrwmo2</code></li> <li><code>uefrmo3</code></li> <li> \u00bfQu\u00e9 es Electronic Journal? <li> \u00bfQu\u00e9 es TLog? <li> \u00bfQu\u00e9 es Middleware?   Es el componente que se encarga de redireccionar las peticiones hacia framework o Dominio</li> <li> \u00bfQu\u00e9 es Middleware Cloud?</li> <li> \u00bfQu\u00e9 es Interface?   Es el encargado de interpretar el mensaje recibido via <code>Middleware</code> desde <code>BASIC</code> y enviarlo al <code>Director</code></li> <li> \u00bfQu\u00e9 es DataEntry?   Es un conjunto de subgrupos que se encargan de marcar un item con unas caracteristicas que desencadenan flujos especiales al momento de la venta y pago. Por ejemplo la venta de una tarjeta de Netflix.</li> <li> \u00bfQu\u00e9 son CallJavaBasic?   Es el protocolo de comunicaci\u00f3n usado actualmente para transferir informaci\u00f3n entre BASIC y JAVA.</li> <li> \u00bfQu\u00e9 diferencia Pago, Venta y No Venta? Venta es la intenci\u00f3n de compra de un item por parte de un cliente y que afecta tantos los inventarios como el flujo de dinero de ls compa\u00f1ia   No Venta es la operaci\u00f3n que no afecta los inventarios de la compa\u00f1ia y presta el servicio de un tercero como son las recargas, lo giros, las apuestas, etc.   Pago es el \u00faltimo paso que cierra la transacci\u00f3n y asienta la venta de un item.</li> <li> \u00bfLa comunicacion va a ser ISO o HTTP?"},{"location":"apuntes.html#tareas","title":"Tareas","text":"<ul> <li> revisar la arquitectura actual (framework)</li> <li> Entender el flujo del proceso y la relaci\u00f3n de componentes</li> <li> revisar la arquitectura a implementar (dominio)</li> <li> consultar migraciones previas</li> <li> Solicitar ambiente</li> <li> Si es relevante, conocer los PLU de los servicios ofrecidos</li> <li> Revisar componentes de producci\u00f3n</li> </ul>"},{"location":"apuntes.html#mis-notas","title":"Mis Notas","text":"<ul> <li>ISOService: componente del lado del Dominio para manejar las tramas ISO8583</li> <li>JSON con capa de seguridad</li> <li>Operaciones</li> <li>Pagos</li> <li>Ventas</li> <li>Intercambio de medio de pago</li> <li>Eventos</li> <li>Objeto POSTransaction: Estandar de todos los productos del negocio. Es decir, que atributos hacen parte de cada transaccion dependiendo el producto.</li> <li>Orden jeraquico:</li> <li><code>VentaContenidos.jar</code> (bp)</li> <li><code>FrameworkContenidosPagos.jar</code> (platform)</li> <li><code>Reportes.jar</code>, <code>Persist.jar</code> o <code>Presentacion.jar</code> (libs)</li> <li>Arquitectura</li> <li> <p>Framework</p> <ul> <li> Arquitectura Framework </li> </ul> </li> <li> <p>Dominio</p> <ul> <li> Arquitectura Dominio </li> </ul> </li> <li> <p>Modelo de Dominio</p> </li> <li>immergeTransportObject</li> <li>emmergeTransportObject</li> <li>transaccion positiva: Se ingresa al modelo de dominio</li> <li>transaccion negativa: Se retira al modelo de dominio</li> <li>bifrost: afectaci\u00f3n de la base de datos</li> <li>prevalidaciones</li> <li>posvalidaciones</li> <li>Dia de Duvan y Bernie</li> <li>Tener un Dise\u00f1o con base a recomendaciones</li> <li>Continuidad: Autorizador falla no se bloquee el POS (Resiliencia)</li> <li>Trazabilidad: Logs a escribir</li> </ul>"},{"location":"apuntes.html#componentes-relacionados","title":"Componentes relacionados","text":"<ul> <li><code>fwvdc.dat</code>: Productos para la venta</li> <li><code>fwvdcont.dat</code>: Configuraciones del Product Bussiness</li> </ul>"},{"location":"apuntes.html#roadmap","title":"RoadMap","text":""},{"location":"apuntes.html#etapa-preliminar","title":"Etapa preliminar","text":"<p><sub>E: Estado actual - A: Acciones a seguir</sub></p> <ul> <li> Evaluar el estado actual del software y sus dependencias:</li> <li> Analizar el c\u00f3digo fuente del software existente. (\u00bfhay repos y estan actualizados?)<ul> <li>E: Hasta el momento no se encuentra discrepancia entre lo revisado y lo que est\u00e1 funcionando en producci\u00f3n</li> <li>A: Seguir atento</li> </ul> </li> <li> Revisar la documentaci\u00f3n y comprender las dependencias del sistema.<ul> <li>E: La documentaci\u00f3n da una vision general de las arquitecturas pero no est\u00e1 actualizada con los cambios posteriores.</li> <li>A: Revisar los flujos</li> </ul> </li> <li> Identificar posibles problemas o limitaciones del SW que no permitan la migraci\u00f3n.<ul> <li>E: No se evidencian acoplamientos que dificulten la migraci\u00f3n en este PB.</li> <li>A: Revisar flujos</li> </ul> </li> <li> Analizar los riesgos y beneficios de la migraci\u00f3n:</li> <li> Identificar los posibles riesgos asociados con la migraci\u00f3n.<ul> <li>Dependencias ocultas o Casos de Uso que no esten identificados en la primera inspecci\u00f3n y dificulten la integracion en el DOM</li> </ul> </li> <li> Evaluar los beneficios esperados al llevar a cabo la migraci\u00f3n.<ul> <li>Escalabilidad</li> <li>Mantenibilidad</li> <li>Mejoras en Persistencia</li> <li>Mejoras en Comunicaci\u00f3n</li> </ul> </li> <li> Definir el alcance de la migraci\u00f3n:</li> <li> Identificar los componentes espec\u00edficos del sistema que se migrar\u00e1n.<ul> <li>Se migrar\u00e1 la funcionalidad de Ventas Contenido sin ninguna caracteristica nueva</li> </ul> </li> <li> Establecer los criterios tecnicos para determinar qu\u00e9 aspectos del sistema se mantendr\u00e1n sin cambios. (MUY IMPORTANTE)</li> <li> Considerar aspectos tecnicos que impacten el rendimiento y la escalabilidad.</li> <li> Establecer plazos de tiempo</li> <li> Realizar un inventario de componentes</li> <li> Evaluar tecnolog\u00edas a implementar:</li> <li> Detectar ventajas y desventajas de cada tecnolog\u00eda para tomar decisiones informadas. (MUY IMPORTANTE)</li> <li> Entender la arquitectura del DOM:</li> <li> Dise\u00f1ar diagramas que representen la estructura y la interacci\u00f3n de los nuevos componentes del sistema. (RAYAR)<ul> <li></li> </ul> </li> <li> Definir patrones de migraci\u00f3n:</li> <li> Identificar los patrones de dise\u00f1o adecuados para cada componente.</li> <li> Determinar si se requiere refactorizaci\u00f3n, reingenier\u00eda u otros enfoques para migrar cada componente.</li> <li> Definir protocolos de comunicaci\u00f3n a otra capas. (Pesistencia - Middleware Cloud)</li> <li> Preparar el entorno de desarrollo y pruebas:</li> <li> Configurar un entorno de desarrollo.</li> <li> Establecer infraestructuras de prueba en entorno controlado. (MUY IMPORTANTE)</li> </ul>"},{"location":"apuntes.html#etapa-de-migracion","title":"Etapa de migraci\u00f3n","text":"<ul> <li> Ejecutar la migraci\u00f3n del servicio:</li> <li> Realizar las acciones necesarias para migrar cada componente. (Creaci\u00f3n de nuevos componentes del lado del controlador)</li> <li> Transferir configuraciones y datos relevantes al nuevo entorno.</li> <li> Implementaci\u00f3n de estrategia de registros (LOGS)</li> <li> Realizar pruebas unitarias (integraci\u00f3n - aceptaci\u00f3n):</li> <li> Desarrollar casos de prueba para verificar el funcionamiento correcto de cada componente migrado. (QA)</li> <li> Ejecutar pruebas unitarias para identificar y corregir posibles problemas. (IDEAL)</li> <li> Validaci\u00f3n de la integridad de los datos migrados/generados:</li> <li> Verificar que los datos migrados sean consistentes y precisos.</li> <li> Realizar pruebas integraci\u00f3n. (QA)</li> <li> Observar el rendimiento:</li> <li> Monitorear el rendimiento del servicio en t\u00e9rminos de eficiencia y resiliensia.</li> <li> Ajustes (Refactory).</li> <li> Observar la escalabilidad:</li> <li> Enfoque a principio Open-Close.</li> <li> Realizar pruebas de carga y estr\u00e9s para medir la capacidad de escalabilidad del sistema. (IDEAL)</li> </ul>"},{"location":"apuntes.html#etapa-posterior-a-la-migracion","title":"Etapa posterior a la migraci\u00f3n","text":"<ul> <li> Documentaci\u00f3n:</li> <li> Registrar todos los cambios realizados durante el proceso de migraci\u00f3n ademas de actualizaciones de c\u00f3digo, configuraciones y otros cambios relevantes.</li> <li> Realizar pruebas finales (Aseg. Calidad) y monitorear el funcionamiento del sistema (Piloto) (QA)</li> <li> Evaluar el \u00e9xito de la migraci\u00f3n en relaci\u00f3n con los objetivos definidos</li> <li> Ajustes y refactorizaci\u00f3n:</li> <li> Realizar ajustes adicionales o refactorizaci\u00f3n del sistema migrado en base a la retroalimentaci\u00f3n y los resultados obtenidos.</li> <li> Corregir posibles errores o deficiencias identificadas durante la etapa de pruebas.</li> </ul>"},{"location":"backlog.html","title":"Backlog","text":"<ul> <li> Resolver comunicaciones hacia el autorizador (primer alternativa con dummies)</li> <li> Considerar los par\u00e1metros que son datos pero que hacen parte de la situaci\u00f3n actual (hch - fwdcon - fwvdc)</li> <li> Incluir LdsMiddleware en el flujo</li> <li> Reunion con el equipo de desarrollo para socializar definiciones</li> <li> Revisar capitulo de encolamiento y reversos (Andr\u00e9s)</li> <li> Seguridad (Alexis)</li> <li> transacciones</li> <li> Protecci\u00f3n de las estructuras de las configuraciones</li> <li> Definir estrategia de componente BASIC (Mauro)</li> <li> Se crea un nuevo componente</li> <li> Detallar y definir llamados est\u00e1ndar</li> </ul>"},{"location":"bitacora.html","title":"Definiciones","text":""},{"location":"bitacora.html#24-05-2024","title":"24-05-2024","text":"Detalles"},{"location":"bitacora.html#29-05-2024","title":"29-05-2024","text":"<ol> <li>Pruebas de <code>webFly</code> y <code>jetty</code> sobre la terminal</li> <li>Se mantienen los llamados <code>java-basic</code></li> <li>Implementar estrategia de  notificaci\u00f3n a BASIC cuando JAVA no responda, para evitar bloqueos en la terminal. Se pueden emplear Pipe para efectos de controlar  dicho escenario.</li> <li>reducir/optimizar los llamados Java-basic.</li> <li>Prueba de concepto en un ambiente nativo haciendo todo el flujo en el contexto de 4690/Sky: Los datos viajan v\u00eda AEF, es decir,  es vocaci\u00f3n de basic entregar datos java, no por el call java basic, para que esta data se refleje en java ( lo llamamos contexto de la TRX). El call java basic sigue operando pero su vocaci\u00f3n es solo hacer peticiones a java (formato json), y recibir respuestas del contexto de ejecuci\u00f3n de Java (Ej: Venta ok, Venta Nok, pago ok, Pago Nok, etc.).</li> </ol> <pre><code>sequenceDiagram\n    participant basic as BASIC\n    participant api as Java-BASIC API\n    participant aef as AEF\n    participant cj as Componente-Java\n    basic-&gt;&gt;api: UserExit\n    basic-&gt;&gt;aef: XML\n    api-&gt;&gt;cj: RMI\n    cj-&gt;&gt;aef: request\n    aef--&gt;&gt;cj: response\n    alt Trx OK\n        cj--&gt;&gt;api: response\n        api--&gt;&gt;basic: response\n    else Trx NOK\n        cj--&gt;&gt;api: response\n        api--&gt;&gt;basic: response\n    end\n    basic-xbasic: continua operaci\u00f3n</code></pre> <ol> <li> <p>Se construir\u00e1 un/os componentes  (parte llamada adaptadores en la imagen) los cuales est\u00e1n en el contexto de la plataforma de Toshiba para \"convertir\" la data para el nuevo modelo (input), dentro de las responsabilidades de este adaptador esta: Captura de la informaci\u00f3n ingresados por el usuario (control del IO processor) Almacenamiento en el TLOG Impresi\u00f3n (reportes) Etc...</p> </li> <li> <p>Los llamados java basic deber\u00edan ser iguales a las user Exits de SA?....</p> <p> </p> </li> </ol> <p>Siguientes pasos:</p> <p>Hacer una PoC del flujo de basic a java (AEF) para disponibilizar los datos de la trx en lo que llamamos contexto de la TRX en un entorno nativo Toshiba. Crear llamado java-basic en donde basic genera el formato de petici\u00f3n y respuesta en json Crear componente(s) en java para hacer la captura, mostrar datos, etc.  desde java y un componente basado en servicio que resuelva una l\u00f3gica particular por ejemplo un c\u00e1lculo sencillo con datos de la TRX contexto,</p>"},{"location":"bitacora.html#18-06-2024","title":"18-06-2024","text":"<p>Grafico que muestra una primera exploracion de los datos y sus fuentes dentro del conmtexto de la operacion:</p> <pre><code>classDiagram\n    class PosTrx {\n        -code: String\n        -key: String\n        -status: String\n        -operaci\u00f3n: String\n        -date: String\n        -terminal: String\n        -transacci\u00f3n: String\n        -cons: String\n        -store: String\n        -posFields: List&lt;PosField&gt;\n        -active: String\n        -indiceSecuencias: HashMap&lt;Object, Object&gt;\n    }\n\n    class PosField {\n        -name: String\n        -value: String\n        -properties: Properties\n        -persist: boolean\n    }\n\n    PosTrx \"1\" -- \"0..*\" PosField : contains</code></pre>"},{"location":"definiciones.html","title":"ServicesDomainArquitectura de Dominio basada en Microservicios","text":"<p>\u201cLa \u00fanica forma de ir r\u00e1pido es hacerlo bien\u201d - Uncle Bob -</p> <p>La definici\u00f3n de esta nueva arquitectura abarca la construcci\u00f3n y relaci\u00f3n de los componentes que atender\u00e1n las operaciones de VENTA, NO VENTA y PAGO siguiendo las especificaciones definidas por la direcci\u00f3n de SAV.</p> <p>En t\u00e9rminos de investigaci\u00f3n, reto, implementaci\u00f3n y desempe\u00f1o, representa lo siguiente:</p> <ol> <li>Construir soluciones que permitan f\u00e1ciles despliegues en distintos ecosistemas (local - servidor - nube).</li> <li>Acercamiento a arquitecturas ya probadas como son ELERA o similares.</li> <li>Facilitar la implementaci\u00f3n de tecnolog\u00edas m\u00e1s modernas y adecuadas a los recursos existentes y futuros.</li> <li>Mayor flexibilidad para implementar una arquitectura heterog\u00e9nea pero ordenada.</li> <li>Oportunidad de implementar estrategias de resiliencia del sistema.</li> <li>Oportunidad de implementar estrategias de monitoreo eficaces y que comuniquen.</li> <li>Baja dependencia de las limitantes de obsolescencia de software y hardware.</li> <li>Implementaci\u00f3n de est\u00e1ndares del mercado en cuanto a paradigmas de programaci\u00f3n y patrones de dise\u00f1o, estas como gu\u00edas conceptuales - No hay bala de plata -.</li> <li>Posibilidad futura de contenerizar los servicios, lo que proporciona una mayor portabilidad, gobernanza y escalabilidad sobre los mismos.</li> <li>Facilitar la implementaci\u00f3n de medidas de seguridad m\u00e1s robustas y consistentes.</li> <li>Mayor facilidad al a\u00f1adir o actualizar componentes en un \u00fanico punto centralizado cuando sea necesario.</li> <li>Un servicio centralizado puede facilitar la integraci\u00f3n con otros sistemas y servicios externos, mejorando la interoperabilidad.</li> <li>Promover una arquitectura saludable desarrollando software de forma org\u00e1nica.</li> <li>Fomentar la comprensi\u00f3n, la depuraci\u00f3n y la modificaci\u00f3n del c\u00f3digo.</li> <li>Ayudar al equipo de desarrollo a trabajar mas eficientemente</li> <li>Gran objetivo: Mejorar algo que ya funciona. (agregar valor).</li> </ol>"},{"location":"definiciones.html#directrices-generales","title":"Directrices Generales","text":"<p>Para el dise\u00f1o y construcci\u00f3n de la nueva arquitectura se debe tener en cuenta las siguientes orientaciones:</p> <ol> <li>Sus m\u00f3dulos deben ser especializados en atender una y solo una funcionalidad especifica del negocio. (alta cohesi\u00f3n)</li> <li>Deben proveer un mecanismo de comunicaci\u00f3n est\u00e1ndar garantizando una relaci\u00f3n agn\u00f3stica con el resto de componentes. (bajo acoplamiento)</li> <li>Debe poseer en lo posible, caracter\u00edsticas de despliegue en multiples backends. (Multientorno)</li> <li>Estandarizaci\u00f3n para una r\u00e1pida integraci\u00f3n de nuevos servicios. (Servicios orientados a la configuraci\u00f3n)</li> <li>Deben basar su interacci\u00f3n al intercambio m\u00ednimo de mensajes suficientes para realizar su labor, garantizando su independencia y autonom\u00eda.</li> <li>Idealmente indice mas bajo de acoplamiento con tecnolog\u00edas externas y/o servicios ajenos al core del negocio.</li> <li>Observar la implementaci\u00f3n de los principios SOLID, KISS y DRY adem\u00e1s de buenas practicas de CLEAN CODE como pilar fundamental de construcci\u00f3n del c\u00f3digo.</li> <li>Flexibilizaci\u00f3n sobre dogma.</li> <li>Pruebas unitarias.</li> <li>Documentaci\u00f3n t\u00e9cnica.</li> <li>Cultura de desarrollo (Disciplina y buenas pr\u00e1cticas) sobre informalidad e improvisaci\u00f3n.</li> </ol> <p>Estos son grosso modo un buen punto de partida para iniciar el dise\u00f1o y construcci\u00f3n.- ojo, no son dogma -. Es claro que el rumbo se va definiendo en el proceso de desarrollo.</p>"},{"location":"definiciones.html#receta-propuesta-para-abordar-la-solucion","title":"\"Receta\" propuesta para abordar la soluci\u00f3n","text":"<ul> <li>Definir el problema de manera abstracta.</li> <li>Pensar en la soluci\u00f3n en t\u00e9rminos monol\u00edticos y luego descomponer.</li> <li>Representar adecuadamente las entidades del negocio.</li> <li>Dise\u00f1ar la soluci\u00f3n considerando la perspectiva del usuario no la dependencia tecnol\u00f3gica.</li> <li>No suponer.</li> <li>Cada caso de uso debe representar una funcionalidad espec\u00edfica del sistema.</li> <li>Definir la interoperabilidad con tecnolog\u00edas externas mediante interfaces claras cumpliendo las definiciones de las reglas de negocio.</li> <li>Mantener una mentalidad abierta durante todo el proceso.</li> </ul>"},{"location":"definiciones.html#diagrama-de-secuencia-general","title":"Diagrama de secuencia general","text":"<pre><code>sequenceDiagram\n    autonumber\n    actor c as Cajero/POS\n    participant basic as Basic\n    participant gateway as TerminalGateway\n    participant device as DeviceHandler\n    participant collect as DataCollector\n    participant params as ParametersStore\n    participant domain as DomainEngine&lt;br&gt;(venta contenido)\n    participant autor as Prov. Externo&lt;br&gt;(Autorizador)\n    c-&gt;&gt;basic: inicia petici\u00f3n\n    Note right of c: registrar PLU&lt;br&gt;imprimir dato&lt;br&gt;finalizar trx&lt;br&gt;almacenar data\n    basic-&gt;&gt;gateway: activa el proceso y env\u00eda mensaje\n    Note right of basic: datos de la operaci\u00f3n&lt;br&gt;(formato json) \n    gateway-&gt;&gt;collect: normaliza y redirige mensaje\n    collect-&gt;&gt;params: solicita configuraci\u00f3n\n        Note over params: los datos deben estar disponible offline\n    params--&gt;&gt;collect: env\u00eda respuesta\n    alt Necesita datos complementarios \n        collect-&gt;&gt;device: solicita datos\n        loop Tantas veces como datos sean pedidos\n            device-&gt;&gt;c: solicita datos\n        Note over c, device: datos complementarios (seg\u00fan la operaci\u00f3n)\n            c--&gt;&gt;device: devuelve datos\n        end\n        device--&gt;&gt;collect: devuelve datos\n    end\n    collect-&gt;&gt;collect: empaqueta el mensaje\n    collect-&gt;&gt;gateway:transmite mensaje\n    gateway-&gt;&gt;domain: redirige el mensaje\n    domain-&gt;&gt;domain: Aplica l\u00f3gica\n    domain-&gt;&gt;autor: hace la petici\u00f3n\n    alt Respuesta OK\n        autor--&gt;&gt;domain: notifica\n        domain--&gt;&gt;gateway: notifica\n        gateway--&gt;&gt;basic: notifica\n        basic--&gt;&gt;c: notifica\n        c-xc: continua operaci\u00f3n\n    else Respuesta NOK\n        autor--&gt;&gt;domain: notifica\n        domain-&gt;&gt;domain: interpreta y prepara respuesta\n        domain--&gt;&gt;gateway: notifica\n        gateway--&gt;&gt;basic: notifica\n        basic--&gt;&gt;c: notifica\n        c-xc: continua operaci\u00f3n\n    end</code></pre> C4"},{"location":"definiciones.html#componentes","title":"Componentes","text":""},{"location":"definiciones.html#terminalgateway","title":"TerminalGateway","text":"Definiciones Entorno: Terminal Vocaci\u00f3n: Enfocado en la comunicaci\u00f3n y enrutamiento de mensajes (orquestaci\u00f3n del flujo) Interacciones: Recibe peticiones desde un cliente, orquesta hacia el resto del flujo, responde a la petici\u00f3n inicial DataInput: Objeto JSON/GRPC DataOutput: Objecto JSON/GRPC"},{"location":"definiciones.html#datacollector","title":"DataCollector","text":"Definiciones Entorno: Terminal Vocaci\u00f3n: Enfocado en la gesti\u00f3n y manipulaci\u00f3n de datos en la terminal Interacciones: Solicita datos al DeviceHandler, Env\u00eda datos normalizados al TerminalGateway, Actualiza par\u00e1metros en LocalParameterStore DataInput: DataOutput:"},{"location":"definiciones.html#devicehandler","title":"DeviceHandler","text":"Definiciones Entorno: Terminal Vocaci\u00f3n: Enfocado en la interacci\u00f3n con el usuario a trav\u00e9s de dispositivos como el teclado y la pantalla Interacciones: Solicita y muestra informaci\u00f3n al usuario via dispositivos I/O, Valida los datos ingresados seg\u00fan el LocalParameterStore DataInput: DataOutput:"},{"location":"definiciones.html#parameterstore","title":"ParameterStore","text":"Definiciones Entorno: Multientorno Vocaci\u00f3n: Proveer las configuraciones de negocio a los m\u00f3dulos solicitantes mediante peticiones. Interacciones: Comunicaci\u00f3n con m\u00f3dulos cliente. DataInput: DataOutput:"},{"location":"definiciones.html#localparameterstore","title":"LocalParameterStore","text":"Definiciones Entorno: Terminal Vocaci\u00f3n: Proveer las configuraciones de negocio a los m\u00f3dulos de al terminal solicitantes mediante peticiones. Interacciones: Provee la cantidad y caracter\u00edsticas de par\u00e1metros al DataCollector garantizando la alta disponibilidad DataInput: DataOutput:"},{"location":"definiciones.html#domainengine","title":"DomainEngine","text":"Definiciones Entorno: Multientorno Vocaci\u00f3n: Proveer la l\u00f3gica necesaria para manejar, transformar, calcular y enrutar los datos recibidos con el fin de entregar un resultado que satisfaga las necesidades de la operaci\u00f3n. Interacciones: Comunicaci\u00f3n con m\u00f3dulos cliente. DataInput: DataOutput:"},{"location":"definiciones.html#jbadapter","title":"JBAdapter","text":"Definiciones Entorno: Terminal Vocaci\u00f3n: Mediador entre JavaAPI y TerminalConfiguration Interacciones: JavaAPI - TerminalGateway DataInput: DataOutput:"},{"location":"definiciones.html#aefadapter","title":"AEFAdapter","text":"Definiciones Entorno: Terminal Vocaci\u00f3n: Mediador entre AEF u otro mecanismo de persistencia del lado del POS y el DataCollector. Interacciones: AEF - DataCollector DataInput: DataOutput:"},{"location":"definiciones.html#tecnologias","title":"Tecnolog\u00edas","text":"<ul> <li>BASIC</li> <li>Java 1.8</li> <li>Spring Boot 2.7.12</li> <li>Maven</li> <li>junit 5.x</li> <li>Mockito 3.x</li> <li>JaCoCo</li> <li>Lombok</li> <li>Logback (definido por equipo a cargo)</li> <li>tomcat / tomEE</li> <li>rest / grpc</li> <li>swagger</li> <li>caffeine (manejo de cach\u00e9)</li> </ul>"},{"location":"definiciones.html#patrones","title":"Patrones","text":"<ul> <li>SAGAs (acci\u00f3n compensatoria) coreograf\u00eda u orquestaci\u00f3n</li> <li>(transaccionalidad distribuida)</li> </ul>"},{"location":"definiciones.html#arquitectura-de-puertos-y-adaptadores","title":"Arquitectura de puertos y adaptadores","text":"<p>Es un estilo de arquitectura de software que enfatiza la separaci\u00f3n de la l\u00f3gica de negocio de las dependencias t\u00e9cnicas externas. La idea es pensar en la aplicaci\u00f3n como el artefacto central de un sistema, donde toda la entrada y salida llega o sale de la aplicaci\u00f3n a trav\u00e9s de un puerto que a\u00edsla la aplicaci\u00f3n de herramientas, tecnolog\u00edas y mecanismos de entrega externos. La aplicaci\u00f3n no deber\u00eda tener conocimiento de qui\u00e9n o qu\u00e9 est\u00e1 enviando la entrada o recibiendo su salida. Esto tiene como objetivo brindar cierta protecci\u00f3n contra la evoluci\u00f3n de la tecnolog\u00eda y los requisitos comerciales, que pueden hacer que los productos queden obsoletos poco despu\u00e9s de su desarrollo, debido al bloqueo de la tecnolog\u00eda o del proveedor.</p> Diagrama de puertos y adaptadores"},{"location":"definiciones.html#capa-de-dominio","title":"Capa de dominio","text":"<p>Contiene los elementos que representan el n\u00facleo de la l\u00f3gica de negocio:</p> <ul> <li>Entidades: Son objetos del modelo de dominio que tienen identidad propia y un ciclo de vida persistente. Representan conceptos del negocio y contienen tanto datos como comportamiento.</li> <li>Agregados: Son agrupaciones de entidades relacionadas que se tratan como una unidad \u00fanica para ciertas operaciones de negocio. Cada agregado tiene una entidad ra\u00edz que garantiza la consistencia del agregado.</li> <li>Objetos de Valor: Son objetos que se definen por sus atributos en lugar de una identidad propia. Representan conceptos inmutables y peque\u00f1os, como cantidades, fechas o coordenadas.</li> <li>Servicios de Dominio: Contienen l\u00f3gica de negocio que no encaja naturalmente dentro de una entidad o un objeto de valor. Son operaciones del dominio que involucran a m\u00faltiples entidades o agregados.</li> <li>Repositorios (Interfaz): Definen contratos para la persistencia y recuperaci\u00f3n de agregados y entidades. Los repositorios en la capa de dominio son solo interfaces; las implementaciones est\u00e1n en los adaptadores.</li> <li>F\u00e1bricas: Son responsables de la creaci\u00f3n compleja de objetos de dominio, especialmente cuando la creaci\u00f3n implica m\u00faltiples pasos o dependencias entre objetos.</li> </ul>"},{"location":"definiciones.html#capa-de-aplicacion","title":"Capa de aplicaci\u00f3n","text":"<p>Act\u00faa como intermediaria entre la capa de dominio y capa de infraestructura. Esta capa orquesta la l\u00f3gica de negocio contenida en la capa de dominio, coordinando tareas y aplicando pol\u00edticas.</p> <ul> <li>Casos de Uso: Definen las operaciones espec\u00edficas de la aplicaci\u00f3n que un usuario puede realizar. Son m\u00e9todos de alto nivel que utilizan los servicios de aplicaci\u00f3n para ejecutar la l\u00f3gica de negocio.</li> <li>Servicios de Aplicaci\u00f3n: Coordinan las operaciones del negocio, llamando a los servicios de dominio y manejando transacciones. No contienen l\u00f3gica de negocio en s\u00ed misma, sino que orquestan las llamadas a los componentes de dominio.</li> <li>DTOs: Transfieren datos entre las capas. Facilitan la serializaci\u00f3n y deserializaci\u00f3n de datos y son objetos simples sin l\u00f3gica de negocio.</li> </ul>"},{"location":"definiciones.html#capa-de-infraestructura","title":"Capa de infraestructura","text":"<p>Contiene todos los detalles t\u00e9cnicos y las implementaciones concretas necesarias para que la aplicaci\u00f3n funcione correctamente. Esta capa se encarga de proporcionar la infraestructura necesaria para soportar las operaciones definidas en las capas de aplicaci\u00f3n y dominio.</p> <ul> <li>Implementaciones de Repositorios: Implementan las interfaces de repositorio definidas en la capa de dominio, utilizando tecnolog\u00edas espec\u00edficas.</li> <li>Servicios de Infraestructura: Proveen integraci\u00f3n con sistemas externos, manejo de archivos, etc.</li> <li>Adaptadores de Entrada y Salida: Implementan la l\u00f3gica para comunicarse con sistemas externos (adaptadores de salida) y para recibir comunicaciones de sistemas externos o interfaces de usuario (adaptadores de entrada).</li> <li>Configuraci\u00f3n: Incluye archivos de configuraci\u00f3n, configuraci\u00f3n de dependencias, configuraci\u00f3n de beans de Spring, etc.</li> <li>M\u00f3dulos de Seguridad: Manejan la autenticaci\u00f3n y autorizaci\u00f3n de usuarios y servicios.</li> </ul>"},{"location":"definiciones.html#scaffolding-basado-en-arquitectura-de-puertos-y-adaptadores","title":"Scaffolding basado en arquitectura de puertos y adaptadores","text":""},{"location":"definiciones.html#quien-eres-y-de-que-tipo-vertical-slicing-screaming-arch","title":"Qui\u00e9n eres y de qu\u00e9 tipo (Vertical Slicing - Screaming Arch)","text":"<p>Vertical Slicing es una t\u00e9cnica de desarrollo que divide una aplicaci\u00f3n en incrementos funcionales completos, cada uno abarcando todas las capas necesarias (UI, l\u00f3gica de negocio y persistencia) para entregar valor de manera incremental y reducir riesgos. Screaming Architecture, sugiere que la estructura del software debe reflejar claramente su prop\u00f3sito y dominio, con m\u00f3dulos organizados seg\u00fan los conceptos del negocio en lugar de detalles t\u00e9cnicos, lo que mejora la comprensi\u00f3n, mantenibilidad y flexibilidad del sistema.</p>"},{"location":"definiciones.html#uso-de-arquetipos","title":"Uso de Arquetipos","text":"<p>Un arquetipo asegura que todos los proyectos sigan una estructura coherente, elimina la configuraci\u00f3n manual inicial, simplifica el arranque con un solo comando, y permite personalizaci\u00f3n y extensi\u00f3n seg\u00fan las necesidades espec\u00edficas del proyecto.</p> <ul> <li>Est\u00e1ndares Consistentes.</li> <li>Ahorro de Tiempo.</li> <li>Facilidad de Uso.</li> <li>Flexibilidad.</li> </ul> Arq. de puertos y adaptadores <pre><code>|   .gitignore\n|   pom.xml\n|   README.md\n|\n+---src\n    +---main\n    |   +---java\n    |   |   \\---com\n    |   |       \\---lds\n    |   |           \\---exito\n    |   |               \\---servicesdomain\n    |   |                   \\---nombre_aplicacion\n    |   |                       |   ServicesDomainApplication.java\n    |   |                       |   ServletInitializer.java\n    |   |                       |\n    |   |                       +---application\n    |   |                       |   +---exceptions\n    |   |                       |   |\n    |   |                       |   \\---usescases\n    |   |                       |\n    |   |                       +---domain\n    |   |                       |   +---exceptions\n    |   |                       |   |\n    |   |                       |   +---models\n    |   |                       |   |\n    |   |                       |   \\---ports\n    |   |                       |       +---input\n    |   |                       |       |\n    |   |                       |       \\---output\n    |   |                       |\n    |   |                       +---infraestructure\n    |   |                       |   +---adapters\n    |   |                       |   |   +---input\n    |   |                       |   |   |\n    |   |                       |   |   \\---output\n    |   |                       |   |\n    |   |                       |   +---configuration\n    |   |                       |   |       OpenApiConfig.java\n    |   |                       |   |\n    |   |                       |   \\---exceptions\n    |   |                       |\n    |   |                       \\---utils\n    |   |\n    |   \\---resources\n    |       |   application.properties\n    |       |   logback.xml\n    |       |\n    |       +---static\n    |       \\---templates\n    \\---test\n        \\---java\n            \\---com\n                \\---lds\n                    \\---exito\n                        \\---servicesdomain\n                            \\---base_exito_services_domain\n                                    ServicesDomainApplicationTests.java\n</code></pre>"},{"location":"definiciones.html#seguridad","title":"Seguridad","text":"<p>Desde el concepto de las seis capas de defensa, implementar protocoles que abarquen protecci\u00f3n en los niveles de:</p> <p>Aplicaci\u00f3n:</p> <ul> <li>validaci\u00f3n de entradas</li> <li>control de versiones en la gesti\u00f3n de dependencias</li> <li>An\u00e1lisis del c\u00f3digo est\u00e1tico con herramientas como el SONAR.</li> <li>Manejo adecuado de errores y excepciones.</li> <li>Observabilidad</li> </ul> <p>Datos:</p> <ul> <li>Cifrado</li> <li>Copias de seguridad y respaldo</li> <li>Clasificaci\u00f3n de datos seg\u00fan su sensibilidad (ofuscaci\u00f3n)</li> </ul>"},{"location":"definiciones.html#reingenieria-de-procesos","title":"Reingenieria de procesos","text":"<p>Pensar si se da la oportunidad, en reestructurar algunos subprocesos y conjunto de datos buscando la optimizaci\u00f3n, jerarqu\u00eda y tipo dentro del universo de la operaci\u00f3n.</p>"},{"location":"dicc-datos.html","title":"Diccionario de datos","text":"<p>el nombramiento de los datos debe ser:</p> <ul> <li>Descriptivo: que evite la ambig\u00fcedad (<code>storeName</code> en vez de <code>store</code>)</li> <li>Conciso: En caso de nombramientos largos buscar su composici\u00f3n mas corta sin que pierda el sentido (ej: <code>authTrxId</code> en vez de <code>authoritationTransactionId</code>)</li> <li>Sin abreviaturas: Excepto abreviaturas propias del contexto del negocio (ej: <code>nut</code>) o muy conocidas en el \u00e1mbito t\u00e9cnico (ej: <code>auth</code>) usadas como prefijos o sufijos (ej: <code>type1x1</code> o <code>authOrReverse</code>)</li> <li>Con un significado \u00fanico: por ejemplo el valor de un PLU en el contexto de venta es <code>itemPrice</code> pero en el contexto de no venta es <code>amount</code></li> <li>En formato <code>camelCase</code> o <code>SCREAMING_SNAKE_CASE</code></li> </ul> <p>Esto con el fin de que en su conjunto sean consistentes con el lenguaje t\u00e9cnico y del negocio, mejorando la legibilidad y comprensi\u00f3n del c\u00f3digo.</p> <p>Se deben evitar:</p> <ul> <li>Nombres gen\u00e9ricos: <code>data</code>, <code>temp</code>, o <code>info</code></li> <li>Mezcla de idiomas: <code>newVlr</code></li> </ul>"},{"location":"dicc-datos.html#del-negocio","title":"Del negocio","text":"Dato Descripci\u00f3n amount valor - precio - monto cashierId N\u00famero de identificaci\u00f3n del cajero date Dato de fecha plu Identificador del Item storeId N\u00famero de la tienda terminalId N\u00famero de la terminal time Dato de hora transactionId N\u00famero de la transacci\u00f3n"},{"location":"dicc-datos.html#transversales","title":"Transversales","text":"Dato Descripci\u00f3n messageResponse Mensaje de respuesta statusResponse C\u00f3digo de respuesta"},{"location":"glosario.html","title":"Glosario","text":"<p>Adaptadores: Son las implementaciones concretas de los puertos. Contienen la l\u00f3gica espec\u00edfica necesaria para conectar el n\u00facleo de la aplicaci\u00f3n con tecnolog\u00edas y servicios externos. Los adaptadores traducen las llamadas entre el n\u00facleo de la aplicaci\u00f3n y los sistemas externos. (Adaptadores de entrada y salida)</p> <p>Contexto de la TRX: Son todos los datos relacionados en el entorno de una compra o procedimeinto de no venta.</p> <p>Contexto de Ejecucion de JAVA: Es la conjunto de informaci\u00f3n que fluye de manera unidireccional desde Java hacia BASIC como respuesta al resultado de una operaci\u00f3n.</p> <p>Modelo del Dominio: Describe las reglas, c\u00e1lculos y procesos que son fundamentales para la operaci\u00f3n del negocio. Ac\u00e1 est\u00e1 la logica del comportamiento esperado del componente y debe ser aislado de componentes externos.</p> <p>Puertos: Son interfaces que definen c\u00f3mo el n\u00facleo de la aplicaci\u00f3n se comunica con el mundo exterior y viceversa. Los puertos no contienen l\u00f3gica de negocio ni detalles de implementaci\u00f3n; simplemente definen contratos que deben cumplirse para interactuar con el n\u00facleo de la aplicaci\u00f3n. (Puertos primarios y secundarios)</p> <p>Datos de Transaccion: Son los datos transversales que se encuentran en una transaccion y hacen parte de la petici\u00f3n del lado del sistema POS.</p> <p>Datos complementarios: Son los datos particulares de cada una de las operaciones y son proporcionados en el transcurso de la operaci\u00f3n.</p>"},{"location":"inventario.html","title":"Inventarios","text":""},{"location":"inventario.html#componentes","title":"Componentes","text":"NOMBRE SERVICIO ARCHIVO FW.DAT JAR DEPENDENCIAS Convenios M\u00f3dulo que permite controlar pagos, consultas y dem\u00e1s operaciones de la tecla de convenios. <code>FWCONVE.DAT</code> <code>JConvenios.jar</code><code>vr 1.4</code> <code>VentasPagos</code><code>BbRulesValidator</code> Garant\u00edaExtendida Modulo para el control de los servicios de CIDOM (control de domicilios)y garantextendida en POS <code>FWGECID.DAT</code> <code>CidomGarantiaExtendida.jar</code><code>vr 1.4</code> <code>VentasPagos</code><code>OS4690TerminalUtilities</code> VentaContenidos M\u00f3dulo que controla las operaciones del servicio de venta de contenidos. <code>FWVDCONT.DAT</code> <code>VentaContenidos.jar</code><code>vr 1.4</code> <code>VentasPagos</code> Facturador M\u00f3dulo de facturacturaci\u00f3n POS para transacciones de Picking. <code>FWMAIN.DAT</code> <code>FacCedicen.jar</code><code>vr 1.8</code> <code>ApiComunicaciones</code><code>Modelo</code><code>Reportes</code><code>slf4j-log4j12</code><code>os4690</code><code>FwUtil</code><code>AEFExtension</code><code>SoaEngine</code><code>DataStore</code><code>SIUser</code><code>libase</code> Orquestador Productos asociados al PINPAD (revisar) - <code>FwKeyOperations.jar</code><code>vr 1.8</code> <code>VentasPagos</code> VentasPagos Posible orquestador ya que tiene mas l\u00f3gica - <code>FrameworkContenidosPagos.jar</code><code>vr 1.8</code> <code>ApiPersistencia</code><code>ApplicationLayer</code><code>Clifre</code><code>DomainLayer</code><code>FwConf</code><code>Modelo</code><code>os4690</code> <code>Presentacion</code><code>Reportes</code><code>smartmod</code> ApiComunicaciones Modulo encargado de realizar la comunicacion hacia el controlador. - <code>ApiComunicaciones.jar</code><code>vr 1.8</code> <code>ApiPinpad</code><code>comm4690</code><code>FwUtil</code><code>jackson-core</code><code>jersey-container-servlet</code><code>jersey-media-json-jackson</code><code>Modelo</code><code>OS4690TerminalUtilities</code><code>rxtxComm</code><code>ServiceConf</code><code>SoaEngine</code><code>TransactionalMessageService</code>"},{"location":"inventario.html#otros-componentesmarcados-ya-se-encuentran-deprecados","title":"Otros componentes<sub><sup>(marcados ya se  encuentran deprecados) <ul> <li> <p>Carpeta \\bp</p> </li> <li> <p> <code>FwOperations.jar</code></p> </li> <li> <code>GirosRemesas.jar</code></li> <li> <code>PagosEfectivoExitoCom.jar</code></li> <li> <code>PuntosExito.jar</code></li> <li> <code>SecurityKey.jar</code></li> <li> <code>TarjetasPropias.jar</code> <sub><sup>(en proceso) <li> <p> <code>Telefonia.jar</code> <sub><sup>(en proceso)  <li> <p>Carpeta \\platform</p> </li> <li> <p> <code>PinpadManaKey.jar</code> <sub><sup>(en proceso)  <li> <code>SumaDescuentos.jar</code> <sub><sup>(ya lo hace motor) <li> <code>CargaEventos.jar</code> <sub><sup>(ya lo hace motor) <li> <code>Clifre.jar</code> <sub><sup>(sigue ligado a convenios) <li> <p> <code>FiadoExito.jar</code></p> </li> <li> <p>Carpeta \\srv</p> </li> <li> <p> <code>Application.jar</code></p> </li> <li> <code>DataStore.jar</code></li> <li> <code>DigitalReceipt.jar</code></li> <li> <code>Director.jar</code></li> <li> <code>Domain.jar</code></li> <li> <code>DomainModel.jar</code></li> <li> <code>Interface.jar</code></li> <li> <code>J8583GrupoExito.jar</code></li> <li> <code>KeyedReader.jar</code></li> <li> <code>Maintenance.jar</code></li> <li> <code>MaintenanceModel.jar</code></li> <li> <code>MessagingHandler.jar</code></li> <li> <code>MessagingHandlerISO.jar</code></li> <li> <code>SecurityService.jar</code></li> <li> <code>ServiceConf.jar</code></li> <li> <code>SoaEngine.jar</code></li> <li> <code>TerminalPersistence.jar</code></li> <li> <code>TransactionalMessageService.jar</code></li> <li> <p> <code>ValidationResponseRevertionStatus.jar</code></p> </li> <li> <p>Carpeta \\libs</p> </li> <li> <p> <code>AbsoluteLayout-RELEASE160.jar</code></p> </li> <li> <code>AEFExtension.jar</code></li> <li> <code>Antlr-2.7.6.jar</code></li> <li> <code>aopalliance-repackaged-2.5.0-b32.jar</code></li> <li> <code>apiguardian-api-1.1.2.jar</code></li> <li> <code>Backport-util-concurrent.jar</code></li> <li> <code>batik-anim-1.16.jar</code></li> <li> <code>batik-awt-util-1.16.jar</code></li> <li> <code>batik-bridge-1.16.jar</code></li> <li> <code>batik-codec-1.9.jar</code></li> <li> <code>batik-constants-1.16.jar</code></li> <li> <code>batik-css-1.16.jar</code></li> <li> <code>batik-dom-1.16.jar</code></li> <li> <code>batik-ext-1.16.jar</code></li> <li> <code>batik-gvt-1.16.jar</code></li> <li> <code>batik-i18n-1.16.jar</code></li> <li> <code>batik-parser-1.16.jar</code></li> <li> <code>batik-script-1.16.jar</code></li> <li> <code>batik-shared-resources-1.16.jar</code></li> <li> <code>batik-svg-dom-1.16.jar</code></li> <li> <code>batik-svggen-1.16.jar</code></li> <li> <code>batik-transcoder-1.16.jar</code></li> <li> <code>batik-util-1.16.jar</code></li> <li> <code>batik-xml-1.16.jar</code></li> <li> <code>Bbrv.jar</code></li> <li> <code>BeanShell.jar</code></li> <li> <code>Biometria.jar</code></li> <li> <code>comm-2.0-2.0.0.jar</code></li> <li> <code>comm4690-1.0.0.jar</code></li> <li> <code>Commons-beanutils-1.7.0.jar</code></li> <li> <code>Commons-collections-3.1.jar</code></li> <li> <code>Commons-collections-3.2.jar</code></li> <li> <code>commons-io-2.11.0.jar</code></li> <li> <code>Commons-lang-2.4.jar</code></li> <li> <code>Commons-logging-1.1.1.jar</code></li> <li> <code>Commons-logging.jar</code></li> <li> <code>Commons-net.jar</code></li> <li> <code>core-3.4.0.jar</code></li> <li> <code>DisplayQRCode.jar</code></li> <li> <code>Dom4j-1.6.1.jar</code></li> <li> <code>Ezmorph-1.0.6.jar</code></li> <li> <code>Freemarker-2.3.23.jar</code></li> <li> <code>FwUtil.jar</code></li> <li> <code>GenerateQRCodeStandAlone.jar</code></li> <li> <code>Gson-2.8.2.jar</code></li> <li> <code>hamcrest-core-1.3.jar</code></li> <li> <code>Hibernate-core-3.3.2.GA.jar</code></li> <li> <code>Hk2-Api-2.5.0-b32.jar</code></li> <li> <code>Hk2-Locator-2.5.0-b32.jar</code></li> <li> <code>Hk2-Utils-2.5.0-b32.jar</code></li> <li> <code>Hsqldb-1.7.3.3.jar</code></li> <li> <code>Jackson-Annotations-2.8.4.jar</code></li> <li> <code>Jackson-Annotations-2.9.0.jar</code></li> <li> <code>Jackson-Core-2.9.4.jar</code></li> <li> <code>Jackson-Core-2.9.6.jar</code></li> <li> <code>Jackson-Databind-2.9.6.jar</code></li> <li> <code>Jackson-Jaxrs-Base-2.8.4.jar</code></li> <li> <code>Jackson-Jaxrs-Json-Provider-2.8.4.jar</code></li> <li> <code>Jackson-Module-Jaxb-Annotations-2.8.4.jar</code></li> <li> <code>jai-imageio-core-1.4.0.jar</code></li> <li> <code>jattach-4.1.1010.jar</code></li> <li> <code>javase-3.4.0.jar</code></li> <li> <code>Javassist-3.4.GA.jar</code></li> <li> <code>Javax.annotation-Api-1.2.jar</code></li> <li> <code>Javax.inject-2.5.0-b32.jar</code></li> <li> <code>Javax.ws.rs-Api-2.0.1.jar</code></li> <li> <code>Jcl-over-slf4j-1.6.6.jar</code></li> <li> <code>jcommander-1.72.jar</code></li> <li> <code>Jdom.jar</code></li> <li> <code>Jersey-Client-2.25.1.jar</code></li> <li> <code>Jersey-Common-2.25.1.jar</code></li> <li> <code>Jersey-Container-Servlet-2.25.1.jar</code></li> <li> <code>Jersey-Container-Servlet-Core-2.25.1.jar</code></li> <li> <code>Jersey-Entity-Filtering-2.25.1.jar</code></li> <li> <code>Jersey-Guava-2.25.1.jar</code></li> <li> <code>Jersey-Media-Jaxb-2.25.1.jar</code></li> <li> <code>Jersey-Media-Json-Jackson-2.25.1.jar</code></li> <li> <code>Jersey-Server-2.25.1.jar</code></li> <li> <code>Json-lib-2.2.3.jar</code></li> <li> <code>Jta-1.1.jar</code></li> <li> <code>Libase-1.3.jar</code></li> <li> <code>Log4j-1.2.17.jar</code></li> <li> <code>Modelo.jar</code></li> <li> <code>Os4690TerminalUtilities.jar</code></li> <li> <code>PackFunction.jar</code></li> <li> <code>Persist.jar</code></li> <li> <code>PinpadService.jar</code></li> <li> <code>Presentacion.jar</code></li> <li> <code>PrintExtension.jar</code></li> <li> <code>Reactive-Streams-1.0.2.jar</code></li> <li> <code>Reactor-Core-3.2.3.RELEASE.jar</code></li> <li> <code>Reportes.jar</code></li> <li> <code>Serial.jar</code></li> <li> <code>Slf4j-api-1.6.6.jar</code></li> <li> <code>Slf4j-log4j12-1.6.6.jar</code></li> <li> <code>SmartMod.jar</code></li> <li> <code>Spring.jar</code></li> <li> <code>Xerces.jar</code></li> <li> <code>Xml-apis-1.0.b2.jar</code></li> <li> <code>xml-apis-ext-1.3.04.jar</code></li> <li> <code>xmlgraphics-commons-2.7.jar</code></li> <li> <code>xpp3_min-1.1.3.4.O.jar</code></li> <li> <code>Xstream-1.1.2.jar</code></li>","text":""},{"location":"inventario.html#comentarios","title":"Comentarios <ul> <li>Que funcionalidades est\u00e1n en Framework actualmente y se encuentran migrados o proximos a migrar</li> </ul>","text":""},{"location":"inventario.html#servicios-migrados","title":"Servicios migrados","text":"<ul> <li>Giros</li> <li>Pines</li> <li>Puntos Exito</li> <li>Suma descuentos <sub><sup>(migrado en Motor de promociones) <li>Carga eventos <sub><sup>(migrado en Motor de promociones) <li>Todos los <code>HCH</code> relacionados del lado del <code>PAF</code></li>"},{"location":"inventario.html#proximos-a-migrar","title":"Pr\u00f3ximos a Migr\u00e1r","text":"<ul> <li>Telefonia.jar</li> <li>Pinpad</li> <li>Fiado Exito</li> <li> <p>Todos los <code>HCH</code> relacionados del lado del <code>PAF</code></p> </li> <li> <p>Consideraci\u00f3n de nuevos servicios o reutilizaci\u00f3n de servicios del lado del servidor de aplicaciones. Evaluar descontinuacion del PAF</p> </li> <li> <p>Pendiente (Alinear con arquitectura de lo ya migrado - objetivo es reutilizaci\u00f3n de componentes)</p> </li> <li> <p>\u00bfQue actores salen?<sub><sup>(falta por definir la correspondencia con cada uno de los servicios.)"},{"location":"inventario.html#hay-reduccion-de-codigo-del-lado-de-basic-llamados-retiro-de-modulos","title":"\u00bfHay reducci\u00f3n de c\u00f3digo del lado de BASIC, llamados, retiro de m\u00f3dulos?","text":"<ul> <li>Pendiente (Se necesita conocer los flujos para saber si hay interacci\u00f3n con componentes Basic)</li> </ul>"},{"location":"inventario.html#estrategia-de-logs","title":"Estrategia de Logs","text":"<ul> <li>Definir si se deben llevar log independientes por servicio o uno solo como est\u00e1 actualmente.</li> </ul>"},{"location":"inventario.html#en-la-medida-del-analisis-dimensionar-que-otros-recursos-vamos-a-necesitar","title":"En la medida del an\u00e1lisis dimensionar que otros recursos vamos a necesitar","text":"<ul> <li>Realizaci\u00f3n de pruebas para observar los flujos y otros componentes que puedan interactuar.</li> <li>Recursos de <code>autorizadores</code></li> <li>Set de pruebas</li> </ul>"},{"location":"inventario.html#evaluacion-de-tecnologias-alternativas","title":"Evaluacion de tecnologias alternativas","text":"<ul> <li>Pendiente (Se considerar\u00eda segun las pruebas de flujo actual)</li> </ul>"},{"location":"inventario.html#lista-tentativa-de-repositorios-a-dar-de-baja","title":"Lista tentativa de repositorios a dar de baja","text":"<ul> <li>BbRulesValidator</li> <li>CargaEventos</li> <li>clifre</li> <li>fastpay</li> <li>FiadoExito</li> <li>FwUtil</li> <li>GirosRemesas</li> <li>hchcidom</li> <li>hchconte</li> <li>hchfac</li> <li>hchgiros</li> <li>hchpc</li> <li>hchpines</li> <li>hchtel</li> <li>hchtr</li> <li>Modelo</li> <li>PagosEfectivoExitoCom</li> <li>PinpadManaKey</li> <li>PinpadService</li> <li>Presentacion</li> <li>properties</li> <li>PuntosExito</li> <li>SumaDescuentos</li> <li>TarjetasPropias</li> <li>Telefonia</li> </ul>"},{"location":"inventario.html#pros-y-contras","title":"Pros y Contras","text":""},{"location":"inventario.html#pros","title":"Pros","text":"<ul> <li>Mantenibilidad.</li> <li>Refactorizaci\u00f3n de cara a mejorar el rendimiento.</li> <li>Posibilidad de implemetar Pruebas Unitarias.</li> <li>Depuraci\u00f3n de c\u00f3digo y componentes obsoletos o huerfanos.</li> <li>Depuracion en la precarga</li> </ul>"},{"location":"inventario.html#contras","title":"Contras","text":"<ul> <li>Riesgo de inestabilidad en el servicio.</li> <li>Depuracion de reportes</li> <li>Configuracion de <code>ATN</code></li> <li>convivencia de ambos (switch de funcionalidad)</li> </ul>"},{"location":"inventario.html#riesgos","title":"Riesgos","text":"<ul> <li>inclusi\u00f3n de recursos no disponibles</li> <li>Costos no contemplados en esta etapa</li> </ul>"},{"location":"java.html","title":"JavaBasic Adapter","text":"Flujo de la informaci\u00f3n desde BASIC a N.Arq detalle de la comunicaci\u00f3n detalle de la comunicaci\u00f3n <p>documento: SO_Programming Guide.pdf (pag 334 - 520)</p> <p>Componente encargado de las comunicaciones entre el servicio <code>TerminalGateway</code> y <code>Java-BASIC API</code>.</p> <p><code>F:</code> Esta en Linux mientras que <code>C:</code> y <code>M:</code> necesitan clases con la terminaci\u00f3n <code>4690</code>, ejemplo <code>FileInputStream4690</code>.</p> <p>Archivos no VFS y no NFS limitan el nombramiento a 8.3, por lo archivos con nombres mas largos son truncados silenciosamente.</p> <p>El sistema de archivos VFS admite nombres de archivo de hasta 256 caracteres de longitud.</p> Package Descripci\u00f3n com.ibm.OS4690 Paquete para clases que proporcionan acceso a varias caracter\u00edsticas del sistema operativo en controladores y terminales de tienda. Estas caracter\u00edsticas incluyen archivos POS, archivos keyed, pipes, estado del sistema y controles del sistema. com.ibm.OS4690.jiop.util Paquete de procesador de entrada/salida de Java para clases de utilidad, como Monitor del Sistema y Depuraci\u00f3n. com.ibm.OS4690.jiop Paquete para clases que proporcionan funciones de procesamiento de entrada/salida en Java. M\u00e9todo Explicaci\u00f3n Patrones SOLID que cumple Patrones SOLID que viola Impacto en el rendimiento del equipo Nivel de acoplamiento Llamadas directas Invocaci\u00f3n directa de m\u00e9todos entre clases Cumple: SRP, OCP, LSP Viola: Ninguno Muy bajo Alto Eventos y bus de eventos Comunicaci\u00f3n mediante eventos asincr\u00f3nicos Cumple: SRP, OCP, DIP Viola: ISP Moderado Bajo Inyecci\u00f3n de dependencias (DI) Gesti\u00f3n de dependencias mediante un contenedor DI Cumple: SRP, DIP Viola: Ninguno Bajo Bajo Memoria compartida/colas locales Comunicaci\u00f3n directa mediante memoria compartida o colas dentro del mismo proceso Cumple: SRP Viola: DIP, OCP Muy bajo Moderado RPC (Remote Procedure Call) Comunicaci\u00f3n mediante llamadas de procedimiento remoto, optimizadas para red local Cumple: SRP, DIP Viola: Ninguno Moderado Moderado Reflexi\u00f3n Uso de reflexi\u00f3n para invocar m\u00e9todos din\u00e1micamente dentro del mismo proceso Cumple: Ninguno Viola: SRP, OCP, LSP Moderado Bajo Comunicaci\u00f3n HTTP Comunicaci\u00f3n mediante llamadas HTTP, usualmente entre procesos o servicios Cumple: SRP, DIP Viola: ISP, LSP Alto Muy bajo"},{"location":"java.html#log-desde-programacion-orientada-a-aspectos-aop","title":"Log desde Programaci\u00f3n Orientada a Aspectos (AOP)","text":""},{"location":"links.html","title":"Links de Inter\u00e9s","text":"<ul> <li>Arquitectura Orientada a Servicios SOA</li> <li>Arquitectura Orientada a Microservicios</li> <li>Arquitectura Hexagonal</li> <li>DDD, Hexagonal, Onion, Clean, CQRS, \u2026 How I put it all together</li> <li>Trello del proyecto</li> <li>Azure del proyecto</li> <li>Wiki del proyecto</li> </ul>"},{"location":"poc.html","title":"Pruebas de Concepto","text":""},{"location":"poc.html#estrategia-de-logeo","title":"Estrategia de logeo","text":""},{"location":"poc.html#actuator","title":"Actuator","text":"<p>Es un m\u00f3dulo de Spring Boot que proporciona funcionalidades para monitorear y administrar una aplicaci\u00f3n. Actuator expone varios puntos finales (endpoints) que permiten acceder a informaci\u00f3n operativa de la aplicaci\u00f3n, tales como m\u00e9tricas, detalles del entorno, informaci\u00f3n sobre beans, detalles de configuraci\u00f3n, y m\u00e1s. Estos endpoints pueden ser muy \u00fatiles para tareas de administraci\u00f3n y monitoreo.</p> <p>Algunos de los endpoints m\u00e1s comunes que proporciona Actuator incluyen:</p> <ul> <li><code>/actuator/health</code>: Proporciona informaci\u00f3n sobre el estado de salud de la aplicaci\u00f3n.</li> <li><code>/actuator/info</code>: Muestra informaci\u00f3n general de la aplicaci\u00f3n, como la versi\u00f3n y otros datos personalizados.</li> <li><code>/actuator/metrics</code>: Ofrece m\u00e9tricas detalladas de la aplicaci\u00f3n, como uso de memoria, n\u00famero de solicitudes HTTP, tiempos de respuesta, etc.</li> <li><code>/actuator/env</code>: Proporciona detalles sobre las propiedades del entorno y sus valores.</li> <li><code>/actuator/beans</code>: Muestra una lista de todos los beans de Spring en la aplicaci\u00f3n. Para habilitar Actuator en una aplicaci\u00f3n Spring Boot, simplemente a\u00f1ade la dependencia spring-boot-starter-actuator en tu archivo pom.xml:</li> </ul> POM.xml<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> application.properties<pre><code>management.endpoints.web.exposure.include=*\n</code></pre>"},{"location":"poc.html#programacion-orientada-a-aspectos-aop","title":"Programaci\u00f3n orientada a aspectos (AOP)","text":"<p>La programaci\u00f3n orientada a aspectos (AOP) es conveniente de implementar en varios escenarios, especialmente cuando:</p> <p>Aspectos transversales: Hay funcionalidades que se repiten en diferentes partes de una aplicaci\u00f3n y no est\u00e1n directamente relacionadas con la l\u00f3gica principal de negocio, como el logging, la seguridad, la gesti\u00f3n de transacciones, etc.</p> <p>Separaci\u00f3n de preocupaciones: Permite separar el c\u00f3digo que implementa funcionalidades espec\u00edficas de la aplicaci\u00f3n (conocido como c\u00f3digo principal o c\u00f3digo base) de las funcionalidades que afectan a varios m\u00f3dulos o capas (conocido como c\u00f3digo de aspecto).</p> <p>Mejora de la modularidad: Facilita la reutilizaci\u00f3n y la gesti\u00f3n de cambios al desacoplar aspectos espec\u00edficos de la aplicaci\u00f3n de su l\u00f3gica central.</p> <p>Mejora de la mantenibilidad: Simplifica la gesti\u00f3n de aspectos que atraviesan m\u00faltiples componentes o capas de una aplicaci\u00f3n, reduciendo la duplicaci\u00f3n de c\u00f3digo y mejorando la legibilidad y mantenibilidad del c\u00f3digo principal.</p> <p>En resumen, AOP es \u00fatil cuando se desea modularizar y gestionar de manera eficiente aspectos que se aplican transversalmente a trav\u00e9s de una aplicaci\u00f3n, sin mezclarlos con la l\u00f3gica principal del negocio.</p>"},{"location":"poc.html#beneficios-de-combinar-actuator-con-aop","title":"Beneficios de combinar Actuator con AOP","text":"<ul> <li>Monitoreo Din\u00e1mico: Puedes ajustar din\u00e1micamente los niveles de logging en funci\u00f3n del comportamiento en tiempo de ejecuci\u00f3n.</li> <li>Separaci\u00f3n de Preocupaciones: AOP permite mantener el c\u00f3digo de logging separado del c\u00f3digo de negocio, manteniendo el c\u00f3digo m\u00e1s limpio y f\u00e1cil de mantener.</li> <li>Mejor Administraci\u00f3n: Actuator proporciona puntos finales que permiten la administraci\u00f3n y monitoreo de la aplicaci\u00f3n sin necesidad de cambios en el c\u00f3digo fuente.</li> </ul> <p>Combinar Actuator con AOP puede proporcionar una soluci\u00f3n robusta para la administraci\u00f3n y monitoreo avanzado de aplicaciones Spring Boot.</p>"},{"location":"serv-app.html","title":"Comparativa de Servidores de Aplicaciones","text":""},{"location":"serv-app.html#jetty","title":"Jetty","text":""},{"location":"serv-app.html#descripcion","title":"Descripci\u00f3n","text":"<p>Jetty es un servidor web y de aplicaciones Java desarrollado por Eclipse Foundation. Es conocido por su ligereza y flexibilidad. Actualmente se encuentra en la versi\u00f3n 12 lanzada en el a\u00f1o 2023</p>"},{"location":"serv-app.html#fortalezas","title":"Fortalezas","text":"<ul> <li>Ligero y r\u00e1pido: Jetty es muy eficiente y tiene un bajo consumo de recursos.</li> <li>Flexible: F\u00e1cil de embedir en aplicaciones Java.</li> <li>Actualizaciones frecuentes: Se actualiza regularmente para mantener la seguridad y el rendimiento.</li> <li>Soporte para WebSockets y HTTP/2: Integraci\u00f3n nativa y eficiente.</li> </ul>"},{"location":"serv-app.html#debilidades","title":"Debilidades","text":"<ul> <li>Menor popularidad: No es tan ampliamente adoptado como Tomcat o WildFly.</li> <li>Funcionalidad limitada fuera del \u00e1mbito web: No est\u00e1 dise\u00f1ado para manejar aplicaciones empresariales complejas.</li> </ul>"},{"location":"serv-app.html#soporte-y-comunidad","title":"Soporte y Comunidad","text":"<ul> <li>Comunidad activa: Aunque no es tan grande como la de Tomcat, tiene una comunidad activa y en crecimiento.</li> <li>Documentaci\u00f3n: Buena, con ejemplos claros y gu\u00edas detalladas.</li> </ul>"},{"location":"serv-app.html#administracion-y-logueo","title":"Administraci\u00f3n y Logueo","text":"<ul> <li>Administraci\u00f3n: Puede ser m\u00e1s complicado de administrar debido a su flexibilidad y configuraci\u00f3n.</li> <li>Logueo: Usa logback o slf4j, que son potentes pero requieren configuraci\u00f3n manual.</li> </ul>"},{"location":"serv-app.html#wildfly","title":"WildFly","text":""},{"location":"serv-app.html#descripcion_1","title":"Descripci\u00f3n","text":"<p>WildFly, anteriormente conocido como JBoss AS, es un servidor de aplicaciones Java EE desarrollado por Red Hat. Actualmente se encuentra en la versi\u00f3n 32 lanzada en el a\u00f1o 2024</p>"},{"location":"serv-app.html#fortalezas_1","title":"Fortalezas","text":"<ul> <li>Completo: Soporte completo para Java EE y Jakarta EE.</li> <li>Escalabilidad: Adecuado para aplicaciones empresariales grandes.</li> <li>Modularidad: Gesti\u00f3n eficiente de recursos gracias a su arquitectura modular.</li> <li>Herramientas de administraci\u00f3n: Consola de administraci\u00f3n web y CLI avanzadas.</li> </ul>"},{"location":"serv-app.html#debilidades_1","title":"Debilidades","text":"<ul> <li>Consumo de recursos: Requiere m\u00e1s memoria y CPU en comparaci\u00f3n con Jetty y Tomcat.</li> <li>Complejidad: Configuraci\u00f3n y administraci\u00f3n m\u00e1s complejas debido a su riqueza en funcionalidades.</li> </ul>"},{"location":"serv-app.html#soporte-y-comunidad_1","title":"Soporte y Comunidad","text":"<ul> <li>Comunidad grande y activa: Amplio soporte y muchas contribuciones de la comunidad.</li> <li>Soporte empresarial: Red Hat ofrece soporte profesional y actualizaciones.</li> </ul>"},{"location":"serv-app.html#administracion-y-logueo_1","title":"Administraci\u00f3n y Logueo","text":"<ul> <li>Administraci\u00f3n: Consola de administraci\u00f3n web intuitiva y herramientas CLI.</li> <li>Logueo: Sistema de logueo robusto, con integraci\u00f3n nativa de JBoss Logging.</li> </ul>"},{"location":"serv-app.html#tomcat","title":"Tomcat","text":""},{"location":"serv-app.html#descripcion_2","title":"Descripci\u00f3n","text":"<p>Tomcat es un contenedor de servlets y servidor web de c\u00f3digo abierto desarrollado por la Apache Software Foundation. Actualmente se encuentra en la versi\u00f3n 10 lanzada en el a\u00f1o 2021</p>"},{"location":"serv-app.html#fortalezas_2","title":"Fortalezas","text":"<ul> <li>Popularidad: Amplia adopci\u00f3n y uso en la industria.</li> <li>Rendimiento: Buen rendimiento para aplicaciones web.</li> <li>Simplicidad: F\u00e1cil de configurar y administrar para aplicaciones web.</li> </ul>"},{"location":"serv-app.html#debilidades_2","title":"Debilidades","text":"<ul> <li>Funcionalidad limitada: No es un servidor de aplicaciones Java EE completo.</li> <li>Escalabilidad limitada: No es ideal para aplicaciones empresariales muy grandes.</li> </ul>"},{"location":"serv-app.html#soporte-y-comunidad_2","title":"Soporte y Comunidad","text":"<ul> <li>Comunidad grande y activa: Gran cantidad de recursos y soporte en l\u00ednea.</li> <li>Documentaci\u00f3n: Extensa y detallada.</li> </ul>"},{"location":"serv-app.html#administracion-y-logueo_2","title":"Administraci\u00f3n y Logueo","text":"<ul> <li>Administraci\u00f3n: Administraci\u00f3n b\u00e1sica pero efectiva a trav\u00e9s de scripts y la interfaz de administraci\u00f3n web.</li> <li>Logueo: Usa java.util.logging por defecto, con soporte para otros sistemas de logueo.</li> </ul>"},{"location":"serv-app.html#pruebas-y-rendimiento","title":"Pruebas y Rendimiento","text":"<p>Se realizan las mediciones y pruebas sobre una terminal controladora con <code>6000Mb</code> de memoria f\u00edsica y <code>5865Mb</code> asignados a linux, conviviendo con el entorno normal de ejecuci\u00f3n (Motor, WebPOS y TomEE):</p> Medicion sin ServApps arriba <p>Se configuran dos tipo de pruebas, una enfocada a la CPU y otra a la RAM con el fin de observar la estabilidad del servidor y del entorno en s\u00ed, ante posibles escenarios de estres. Se toman las siguiente evidencias antes y desp\u00faes de la pruebas:</p>"},{"location":"serv-app.html#jetty_1","title":"Jetty","text":"Instancia servidor sin m\u00f3dulos Instancia servidor con m\u00f3dulos Durante prueba CPU Despues de prueba CPU Durante de prueba RAM Despues de prueba RAM"},{"location":"serv-app.html#wildfly_1","title":"WildFly","text":"Instancia servidor sin m\u00f3dulos Instancia servidor con m\u00f3dulos Durante prueba CPU Despues de prueba CPU Durante de prueba RAM Despues de prueba RAM"},{"location":"serv-app.html#tomcat_1","title":"Tomcat","text":"Instancia servidor sin m\u00f3dulos Instancia servidor con m\u00f3dulos Durante prueba CPU Despues de prueba CPU Durante de prueba RAM Despues de prueba RAM"},{"location":"serv-app.html#tablas-comparativas","title":"Tablas comparativas","text":""},{"location":"serv-app.html#servicios-abajo","title":"Servicios Abajo","text":"JETTY WILDFLY TOMCAT %CPU 0.7 0.7 0.3 %RAM 1.5 5.7 1.7 QRAM-Mb 88.0 334.3 99.7"},{"location":"serv-app.html#servicios-arriba","title":"Servicios Arriba","text":"JETTY WILDFLY TOMCAT %CPU 0.0 0.0 0.3 %RAM 9.3 11.9 8.6 QRAM-Mb 545.4 697.9 504.4"},{"location":"serv-app.html#test-cpu","title":"Test CPU","text":"<p>La prueba consist\u00edo en ejecutar 40 peticiones desde dos clientes a un algoritmo de ordenaci\u00f3n para un array de tama\u00f1o de 10000 n\u00fameros.</p> <p>Lectura durante el test:</p> JETTY WILDFLY TOMCAT %CPU 106.0 129.2 102.0 %RAM 9.7 12.2 9.7 QRAM-Mb 568.9 715.5 568.9 <p>Lectura terminado el test:</p> JETTY WILDFLY TOMCAT %CPU 0.0 0.3 0.0 %RAM 9.8 14.3 9.8 QRAM-Mb 574.8 838.7 574.8"},{"location":"serv-app.html#test-memoria","title":"Test Memoria","text":"<p>La prueba consist\u00edo en ejecutar mediante una petici\u00f3n un algoritmo que produzca una saturaci\u00f3n de la memoria.</p> <p>Lectura durante el test:</p> JETTY WILDFLY TOMCAT %CPU 156.1 141.2 130.6 %RAM 20.1 22.3 19.5 QRAM-Mb 1178.9 1307.9 1143.7 <p>Lectura terminado el test:</p> JETTY WILDFLY TOMCAT %CPU 0.0 0.0 0.3 %RAM 17.5 18.8 19.5 QRAM-Mb 1026.0 1102.6 1143.7 <p>Esta tabla resume la percepci\u00f3n obtenida en la instalaci\u00f3n, manipulacion y pruebas.</p> Caracter\u00edstica Jetty WildFly Tomcat Version testeada 9.4.54 (2016) 26.1.3 (2023) 9.0.90 (2017) Ligereza Alta Media Alta Complejidad<sup>1</sup> Baja Alta Baja Funcionalidades<sup>2</sup> Limitadas Completas Limitadas Administraci\u00f3n Flexible pero compleja Avanzada y completa B\u00e1sica pero efectiva Comunidad Activa pero peque\u00f1a Grande y activa Grande y activa Soporta Java 8 Si Si Si Soporta SpringBoot 2.7.12 Si Si Si"},{"location":"serv-app.html#conclusion-general","title":"Conclusi\u00f3n General","text":"<p>Jetty exhibe consistentemente un bajo consumo de CPU y RAM tanto en condiciones normales como bajo carga, aunque muestra un aumento significativo en el uso de memoria durante pruebas espec\u00edficas de este recurso.</p> <p>WildFly presenta un uso moderado a alto de recursos, especialmente en t\u00e9rminos de RAM y memoria, mostrando robustez bajo cargas intensivas de CPU y memoria en comparaci\u00f3n con Jetty y Tomcat.</p> <p>Tomcat se distingue por su eficiencia en el uso de recursos, manteniendo niveles bajos de consumo de CPU y RAM en la mayor\u00eda de las pruebas, con un rendimiento estable incluso bajo cargas moderadas a intensivas.</p> <p>Cada servidor tiene sus fortalezas: Jetty es ideal para aplicaciones livianas y embebidas que valoran la simplicidad y el rendimiento, aunque puede ser menos adecuado para personalizaciones complejas. WildFly se destaca en entornos empresariales complejos que requieren todas las funcionalidades de Java EE, ofreciendo una administraci\u00f3n avanzada y numerosas opciones de configuraci\u00f3n. Tomcat, conocido por su simplicidad y buen rendimiento, es \u00f3ptimo para aplicaciones web que no necesitan todas las capacidades de Java EE, especialmente con la familiaridad previa con TomEE facilitando su configuraci\u00f3n.</p> <p>Es importante tener en cuenta que las versiones actuales de estos servidores est\u00e1n pr\u00f3ximas a la deprecaci\u00f3n y versiones futuras podr\u00edan no ser compatibles con Java Development Kit 8 (TDK 8).</p> <p>La elecci\u00f3n entre Jetty, WildFly y Tomcat depender\u00e1 principalmente de las necesidades espec\u00edficas de recursos y rendimiento de las aplicaciones, sin profundizar en los detalles de implementaci\u00f3n de cada servidor.</p> <ol> <li> <p>Configuraci\u00f3n inicial, despliegue de aplicaciones, administraci\u00f3n y mantenimiento.\u00a0\u21a9</p> </li> <li> <p>Soporte para especificaciones empresariales, servicios integrados, extensibilidad y plugins, herramientas de administraci\u00f3n, soporte para frameworks y librer\u00edas.\u00a0\u21a9</p> </li> </ol>"},{"location":"state-machine.html","title":"M\u00e1quinas de estados","text":"<ul> <li>Definir los estados</li> <li>definir los eventos y que cambios de estado producen</li> <li>indicar un estado inicial y uno final</li> </ul>"},{"location":"venta-contenido.html","title":"Venta Contenido","text":""},{"location":"venta-contenido.html#capitulos","title":"Cap\u00edtulos","text":""},{"location":"venta-contenido.html#entrada-de-datos-desde-el-cliente","title":"Entrada de datos desde el cliente","text":""},{"location":"venta-contenido.html#payload-del-lado-de-basic","title":"Payload del lado de Basic","text":"<p>Para venta de contenido general llega la siguiente informaci\u00f3n:</p> Datos generales recarga Datos complementarios recarga Datos generales general Datos complementarios general"},{"location":"venta-contenido.html#payload-del-lado-del-dominio","title":"Payload del lado del Dominio","text":"Datos complementarios general"},{"location":"venta-contenido.html#atributos","title":"Atributos","text":""},{"location":"venta-contenido.html#producto","title":"Producto","text":"<ul> <li>nombre (String)</li> <li>PLU (String)</li> <li>EAN (String)</li> <li>hchId (String)</li> <li>tipoContenido (String)s</li> <li>codigoProducto (String)</li> <li>permiteAnulacion (boolean)</li> <li>permiteConsulta (boolean)</li> <li>referencia (Referencia)</li> <li>valor (Valor)</li> <li>voucher (Voucher)</li> </ul>"},{"location":"venta-contenido.html#referencia","title":"Referencia","text":"<ul> <li>solicitaReferencia (boolean)</li> <li>expresionRegular (String)</li> <li>iLongitud (int)</li> <li>iPrefijo (int)</li> </ul>"},{"location":"venta-contenido.html#valor","title":"Valor","text":"<ul> <li>expresionRegular (String)</li> </ul>"},{"location":"venta-contenido.html#voucher","title":"Voucher","text":"<ul> <li>titulo (String)</li> <li>PieVoucherInicial (String)</li> <li>PieVoucherFinal (String)</li> </ul>"},{"location":"venta-contenido.html#almacen-de-datos","title":"Almac\u00e9n de Datos","text":"Dato Descripci\u00f3n AdditionalData Informaci\u00f3n adicional que retorna un pago o item [Solo para tarjetas propias] AdditionalFeatures Caracteristicas adicionales del item o del pago addNewVariablesToReport Caracteristicas adicionales del \u00edtem o del pago Amount Valor de el pago, item o nosale AnulationStatus Identifica el Estado de la Anulacion AnulationType Identifica el Tipo de Anulacion AuthEndProduct parametro para indicar si el authend se realizara por producto AuthorizationBus Identifica el bus de autorizaciones que debe usar el producto AuthorizationClassName Identifica la clase para la autorizacion. AuthorizationDetails Mapa de detalles de la autorizaci\u00f3n AuthorizationIsRequired Indica si requiere autorizacion el item AuthorizationRequired Identifica si se debe de autorizar alguna operacion AuthorizationStatus Identifica el estado de la autorizacion AuthorizationType Identifica el tipo de autorizacion AuthorizationValidatorClassName Identifica la clase validador de respuestas en autorizaci\u00f3n. AuthorizerPort Puerto del autorizador AuthOrReverse Identifica si la operacion fue exitosa al autorizar o hacer el reverso AvailablePoints Puntos disponibles BillableData Billable BillingModality C\u00f3digo de modalidad de facturaci\u00f3n BinTp Codigo del barcode capturado para tarjetas propias ButcheryCommandBarcode Barcode that identifies the butchery command CardNumber Card number CashierId Numero de identificaci\u00f3n del cajero CashierName Nombre del cajero CATALOG identificador tarjeta regalo con catalogo ClassNameQueryAuthEndProductName clase por defecto para la consulta de authend ClifredCed Dato de ClifredCed ClifredOn Dato de ClifredOn consecutiveStatus Identifica bloqueo por consecutivo fiscal CONVENIO Identificador del convenio para la tarjeta regalo con catalogo CustomerBalance Saldo disponible del cliente CustomerDetails Mapa de detalles del customer CustomerEmployeeDiscountId Identificador de descuento del cliente CustomerId Numero de identificacion del cliente CustomerName Nombre del cliente customerQueryRappi Consulta del CustomerQuery de RappiPayless CustomerType Tipo de cliente CustomerTypeId Tipo de documento del cliente CustomerVentaStaff Tipo trx de venta custumerDetails Mapa de detalles del customer DataAdminVariables Variables capturadas en las operaciones no sale Administrativas DataCaptureVariables Variables solicitadas en el datacapture Date Dato de fecha Dependence Dependencia DescriptorTag Indica el tag del descriptor. Este tag se usa para reconocer el tipo de descriptor PaymentItemDescription, TransactionRecord o LogRecord Device Identificador de dispositivo externo DigitalReceiptIndicator Tirilla Digital DocumentType Simple document type ElectronicJournals IDs de descriptores para registrar en el log de soporte electronico ElectronicLogRecord UserString generado para pago o item Email Correo electronico EndDate Fecha final de la resoluci\u00f3n EndRange Rango final del consecutivo fiscal Event Codigo de evento, nosale EventBolsillo Dato de evento bolsillo EventCod Dato telefono EventCodeQuota Codigo evento Descuento Empleado EventData Dato de evento, nosale EventName Dato nombre de evento ExpiricyDatePoints Fecha de expiracion de los puntos ExternalApprovalCode C\u00f3digo de aprobaci\u00f3n de autorizador externo FiscalConsecutiveNumber Consecutivo fiscal FiscalNumber Numero fiscal FiscalTicketNumber Numero de tikete fiscal Footers Lista de IDs para vouchers tipo footer (atados a la tirilla) Frank franqueo Frank String de franqueo HabeasDataIndicator Estado del habeas data IdDevueltas Variable que guardara la cedula para devueltas monedero IndTypeValidation Inidicador tipo de validacion a realizar InitialRange Rango inicial del consecutivo fiscal InputType Input method InternalOperationVersion Variable para identificar en los llamados entre capas, la version de la operacion a realizar IsAddNewVariableToReports Valida si debe agregar nuevas variables al PaymentDetail IsJoinableTrace Indica si el mensaje de una autorizaci\u00f3n se debe unir con varios \u00edtems (no aplica para pagos) IsRecoveryConsult Indica si la transaccion de recovery es solo de consulta ItemDescription Descripcion del item ItemDetails Mapa de detalles del item ItemDiscountIva Descuento por iva diferencial ItemExtension Extension funcional del item ItemExtensionAlternative Extension funcion alterna del item ItemPrice Precio del item ItemQuantity Cantidad del item ItemType modo de venta del item Journal Journal en el login de la terminal Key Indica un id de tecla que se est\u00e1 ejecutando en el momento del pago LastStatus \u00daltimo status retornado al servicio externo LenMax OUTGOIN LenMin OUTGOIN LineDescriptor Descriptor para el item o el pago Max OUTGOIN Min OUTGOIN MonthsValidity Meses de validaci\u00f3n de la resoluci\u00f3n NegativeElectronicJournals IDs de descriptores para registrar en el log de soporte electronico NegativeFooters Lista de IDs para vouchers tipo footer (atados a la tirilla) NegativeFrank franqueo negativo NegativePaymentItemDescription Descripcion del medio de pago para la tirilla NegativeRecoveryRecord IDs de descriptor de recuperacion de registro de operacion extendida en la transaccion NegativeTraceIdentificator Identificador del mensaje negativo para autorizaci\u00f3n NegativeTransactionRecords IDs de descriptores de registro de operacion en la transaccion NegativeVouchers Lista de IDs para vouchers tipo voucher (no atados a la tirilla) NewVlr Valor nuevo capturado para responderle a basic NoSaleOperation Nombre de operacion de no venta NoSaleOperationDetails Detalle de la operacion de no venta NoSaleOperationIdentificator Identificador del registro de la operacion de no venta para recovery Nut Nut de la operacion realizada, solo aplica para retornos desde la capa de dominio OgEvent Primer codigo de evento, nosale OMSCustomerId OMS customer ID OMSDocumentType OMS document type OperatorId login del cajero orderId Order ID entregado por RappiPayless OriginalTerminalNumber Numero de la terminal OriginalTransactionNumber Numero de la transaccion PasswordIndicator Estado de la clave del cliente paymentAmmount Valor del pago realizado paymentComplement Complemento pago realizado paymentDetails Detalles extras del pago PaymentItemDescription Descripcion del medio de pago para la tirilla paymentTender codigo del medio de pago Plu Item identificator PluDiscount PluDiscount PluName Nombre de pruducto PluPrice plus con precio final PluValueList Lista de plu por valor para venta continua PluVarietyPBR Inidicador de Plu/Variedad para la tabla PRODUCTBUSINESSRULEs Pocket PocketID PointsToExpire Saldo puntos a Vencer PositiveTraceIdentificator Identificador del mensaje positivo para autorizaci\u00f3n Prefix Prefijo PrimaryPhoneNumber Numero telefonico primario del cliente ProductName parametro para indicar el nombre de un producto ProductType Identifica el tipo de producto PromotionDetails Nombre de operacion de no venta de promociones detalles PromotionOperation Nombre de operacion de no venta de promociones QrIntentionId Identifica la intenci\u00f3n de compra con QR Bancolombia qryRappi Consulta de cliente para Rappy RecoveryLogRecord String de recuperacion generado para pago o item RecoveryOriginalTerminalNumber Numero de la terminal original para recovery RecoveryOriginalTransactionNumber Numero de la transaccion original para recovery RecoveryRecord IDs de descriptor de recuperacion de registro de operacion extendida en la transaccion ReportArray Reportes generados ReportSection Seccion del reporte (Footer o Voucher) ReportString Reporte generado RequestHttpAuthorization Mapa de parametros para authorizacion http: hostPrimary, portPrimary, uri, requestHttp RequiresItemValidation Requiere validar Item ResolutionNumber N\u00famero de resoluci\u00f3n ResolutionStatus Estado de la resoluci\u00f3n ResponseAutorization Identifica el estado de la autorizacion o del reverso ResponseIsoTemplate Plantilla a utilizar para respuestas de la mensajeria Iso ResponseMap Outgoing map ResponseMessage OUTGOIN ResponseMessageList Outgoing message list ResponseOption Outgoing option menu ResponseStatus Outgoing message status ReverseStatus Identifica el Estado del Reverso ReverseType Indentifica el Tipo de Reverso SecondaryPhoneNumber Numero telef\u00f3nico secundario del cliente SecurityIndicator Indicador para saber si la tarjeta propia es con o sin seguridad ServiceNumber Variable que guardara el service number para monedero Sign Indica el signo de la operacion, si es TRUE es positiva y si es FALSE es negativa SignS Indica el valor de la operacion StandaloneMaintenanceStatus Estado de la validaci\u00f3n del mantenimiento autom\u00e1tico StandaloneMaintenanceStatusMessage Mensaje de estado de la validaci\u00f3n del mantenimiento autom\u00e1tico StartDate Fecha de inicio de la resoluci\u00f3n StatusClient Estado del cliente StoreName Nombre de la tienda StoreNumber Numero de la tienda Tender c\u00f3digo del medio de pago TerminalNumber Numero de la terminal TicCardNumber Numero de la tarjeta TIC TotalBalance Valor total restante por pagar de la transaccion TransactionLogRecord UserString generado para pago o item TransactionNumber Numero de la transaccion TransactionRecords IDs de descriptores de registro de operacion en la transaccion TsProce Identifica si estamos en un conex o en una venta normal Type1x1 Dato tipo de 1x1 autom\u00e1tico o manual TypeRecovery Identifica si el tipo de Recovery es por IPL o por Suspend TypeReq Identifica que tipo de consecutivo fiscal est\u00e1 activo TypeRes Tipo de captura a realizar en interacci\u00f3n JB en muspellheim TypeValidation Variable que guardara el tipo de validaci\u00f3n a realizar UE User Exit UpdateDate UpdateDate UserExit Identifica la userexit donde se realiza el llamado UserString String secundario para el Tlog ValidatorReportClassName Identifica la clase validador para construcci\u00f3n de variables en los reportes. ValueValidation Valor que se utilizara seg\u00fan el tipo de validaci\u00f3n VarName Dato nombre de valor varName Numero de c\u00f3digo otp para pago Vlr Dato valor Vouchers Lista de IDs para vouchers tipo voucher (no atados a la tirilla) Payload Framework<pre><code>---\ncode: '128'\nkey: \nstatus: '0'\noperacion: '0'\ndate: '19'\nterminal: '180'\ntransaccion: '0001'\ncons: \nstore: '0013'\nactive: '1'\nposFields:\n  BsExclusive: '0'\n  FiscalNumber: '1'\n  DatEnt: '128'\n  InTrx: '0'\n  StoreName: EXT EXITO LAB\n  IO: '0'\n  EcrAmount: '0'\n  CashierId: '22222'\n  Payments: '0'\n  Oper: '0000022222'\n  UE: '08'\n  PluQty: '1'\n  Procedencia: '1'\n  TsProce: \"-1\"\n  ClifreOn: '0'\n  Total: '0'\n  PluName: RECARGA ABIERTA MO\n  CashierName: PRUEBAS 2\n  Plu: '274992'\n  Trx: '0001'\n  TypeReq: '0'\n  VarName: '0013'\n  Vlr: '1000'\n  FiscalTicket: '00000000000001'\n  operador: '22222'\n  fecha: '190724'\n  hora: '1119'\n  horaint: '111954953'\nindiceSecuencias:\n  dato: \n</code></pre> Payload Dominio<pre><code>---\nItemQuantity: '1'\nDataCaptureVariables:\n  dato: \nItemDiscountIva: '0'\nCashierId: '0000022222'\nOriginalTransactionNumber: '0001'\nItemExtension: '999'\nReverseStatus: NOAPP\nItemPrice: '50000'\nSignS: '1'\nProductType: ITEM\nTsProce: \"-1\"\nItemType: '999'\nAuthorizationType: INMDT\nReverseType: NOAPP\nIdDevueltas: '0'\nOriginalTerminalNumber: '180'\nAuthEndProduct: NOAPPLY\nItemDescription: COL NETFLIX $50.00\nIndTypeValidation: POSVALIDATION\nLastStatus: '1'\nAnulationStatus: NOAPP\nAnulationType: APPLY\nPlu: '0000001126976'\nItemExtensionAlternative:\n  dato: \nPluVarietyPBR: '999'\nAuthorizationIsRequired: 'true'\nSign: 'true'\nAuthorizationStatus: PNDNG\n</code></pre> <p>definir las transiciones de la maquina de estados usando un archivo de configuraci\u00f3n externo y el uso de <code>spring-statemachine-core</code> version <code>3.2.0</code></p>"},{"location":"venta-contenido.html#mecanismo-de-configuracion-de-datos","title":"Mecanismo de configuracion de datos","text":""},{"location":"venta-contenido.html#datos-de-entrada-desde-pos","title":"Datos de entrada (desde POS)","text":"<pre><code>{\n    \"plu\": \"12345\",\n    \"terminalId\": \"123\",\n    \"transactionId\": \"1\",\n    \"amount\": \"1000\",\n    \"cashierId\": \"22222\",\n    \"storeId\": \"0013\",\n    \"date\": \"20240725\",\n    \"time\": \"1900\"\n}\n</code></pre>"},{"location":"venta-contenido.html#payload-de-salida-hacia-pos","title":"Payload de salida (hacia POS)","text":"response OK<pre><code>{\n    \"statusResponse\": \"0\",\n    \"messageResponse\": null\n}\n</code></pre> response NOK<pre><code>{\n    \"statusResponse\": \"99\",\n    \"messageResponse\": \"lorem ipsum\"\n}\n</code></pre>"},{"location":"doctecnica/arquitectura-limpia.html","title":"Arquitectura Limpia","text":"<p>Uno de los principales retos en la construcci\u00f3n de sistemas inform\u00e1ticos es mantener la independencia entre sus funcionalidades. Con el tiempo, a medida que estos sistemas crecen y se vuelven m\u00e1s complejos, tienden a acoplarse, convirti\u00e9ndose en monolitos dif\u00edciles de mantener. Este problema ha sido abordado en diversas ocasiones por la comunidad, que ha propuesto distintas soluciones encapsuladas bajo el concepto de Arquitectura Limpia. Este enfoque de dise\u00f1o se basa en la creaci\u00f3n de sistemas modulares, mantenibles y f\u00e1cilmente escalables, con el objetivo principal de separar las preocupaciones y garantizar que las dependencias del sistema est\u00e9n dirigidas hacia el n\u00facleo de la aplicaci\u00f3n, donde reside la l\u00f3gica de negocio.</p> <p>Las soluciones derivadas de la Arquitectura Limpia comparten un principio clave: las dependencias deben fluir de las capas exteriores hacia el n\u00facleo del sistema, y no al rev\u00e9s. Es decir, se busca proteger la l\u00f3gica de negocio de cualquier tipo de dependencia hacia tecnolog\u00edas externas o de terceros, manteni\u00e9ndola aislada de los detalles t\u00e9cnicos. Esto no solo facilita el mantenimiento y la evoluci\u00f3n del sistema, sino que tambi\u00e9n asegura que el negocio pueda adaptarse r\u00e1pidamente a cambios tecnol\u00f3gicos sin comprometer su funcionamiento central.</p>"},{"location":"doctecnica/arquitectura-limpia.html#arquitectura-limpia-en-la-dsa","title":"Arquitectura limpia en la DSA","text":"<p>En la DSA, se busca un enfoque que promueva la separaci\u00f3n de responsabilidades tanto en la relaci\u00f3n entre los componentes como en la construcci\u00f3n interna de cada uno de ellos, sin necesariamente adherirse de forma estricta a un patr\u00f3n definido. Sin embargo, en este contexto, se utiliza como referente la Arquitectura Hexagonal o Arquitectura de Puertos y Adaptadores, la cual propone una visi\u00f3n clara de separaci\u00f3n entre la l\u00f3gica del negocio y el resto del sistema a trav\u00e9s de los siguientes conceptos:</p> <ul> <li> <p>Puerto: Es una interfaz que define un conjunto de operaciones o funcionalidades que el n\u00facleo de la aplicaci\u00f3n espera recibir o proporcionar, facilitando la comunicaci\u00f3n con el mundo exterior (como bases de datos, interfaces de usuario, sistemas externos, etc.). El puerto establece un contrato entre el n\u00facleo de la aplicaci\u00f3n (la l\u00f3gica de negocio) y los adaptadores que interact\u00faan con el exterior. Los puertos especifican qu\u00e9 acciones son posibles sin detallar c\u00f3mo se implementan estas acciones. Son independientes de cualquier tecnolog\u00eda espec\u00edfica, lo que permite que, al cambiar la infraestructura o tecnolog\u00eda externa, solo se necesiten ajustes en los adaptadores, sin afectar la l\u00f3gica de negocio del n\u00facleo.</p> </li> <li> <p>Adaptador: Es un componente que implementa un puerto para conectar el n\u00facleo de la aplicaci\u00f3n con el mundo exterior. Los adaptadores son responsables de traducir y adaptar las interacciones entre el sistema interno (el n\u00facleo) y las tecnolog\u00edas externas (como bases de datos, servicios web, interfaces de usuario, etc.). Implementan los puertos definidos en el n\u00facleo, permitiendo que las funcionalidades del sistema se conecten con componentes externos. Adem\u00e1s, convierten los datos entre el formato entendido por el n\u00facleo de la aplicaci\u00f3n (dentro de la l\u00f3gica de negocio) y el formato requerido por la tecnolog\u00eda externa. Los adaptadores permiten que el sistema se adapte f\u00e1cilmente a nuevas tecnolog\u00edas o herramientas, ya que solo es necesario cambiar el adaptador cuando se sustituye una tecnolog\u00eda o se agregan nuevas funcionalidades externas.</p> </li> </ul> <p>Es asi como vemos en la estructuraci\u00f3n de la DSA-INTERNA que en los \"bordes\" de la arquitectura, la interacci\u00f3n entre componentes externo se da a traves de adaptadores los cuales son los \u00fanicos componentes dentro de la arquitectura que deben conocer e interactuar con otros servicios que no est\u00e9n integrados en la DSA.</p>"},{"location":"doctecnica/arquitectura-limpia.html#construccion-de-componentes","title":"Construcci\u00f3n de componentes","text":"<p>Para la construcci\u00f3n de componentes se provee un arquetipo de maven llamado <code>base-services-dsa-archetype</code>. Este arquetipo provee la estructuraci\u00f3n b\u00e1sica de un proyecto basado en arquitectura de puertos y adaptadores tal como se puede ver en el capitulo de estructuraci\u00f3n de carpetas. Si plasmamos este patron en el flujo de un componente y su relaci\u00f3n entre componentes internos vemos una clara separaci\u00f3n de responsabilidades y desacoplamiento entre el n\u00facleo del sistema y sus dependencias externas:</p> Ejemplo de estructuraci\u00f3n interna del  TerminalGatewayService <p>El componente se divide en tres capas principales que son domain, application e infrastructure. Vemos en la capa superior o mas externa los componentes (azul claro) de tipo adaptador que implementan (en gris) los puertos de tipo interfaz y que existen en la capa mas interna o inferior con el fin de que sean accesibles por las capas superiores. Estos puertos a su vez son usados como fachada por clases concretas que contienen la l\u00f3gica del negocio (azul oscuro).</p> <p>Vemos asi como tanto a nivel de componentes como del componente en si, se adopta el enfoque de arquitectura de puertos y adaptadores sin acoplarse dogm\u00e1ticamente a la literatura del patr\u00f3n y solo siendo usado como gu\u00eda conceptual.</p>"},{"location":"doctecnica/componentes.html","title":"Componentes","text":"<p>La Arquitectura de Servicios de Dominio (DSA) se basa en una estructura modular que organiza los distintos elementos necesarios para implementar y ejecutar sus funcionalidades. Estos componentes trabajan de manera independiente pero colaboran entre s\u00ed para cumplir con los objetivos del negocio, asegurando escalabilidad, flexibilidad y mantenibilidad.</p>"},{"location":"doctecnica/componentes.html#modulos-de-la-dsa","title":"M\u00f3dulos de la DSA","text":"<p>A continuaci\u00f3n, se describen los principales componentes de la arquitectura:</p>"},{"location":"doctecnica/componentes.html#servicios","title":"Servicios","text":"<p>Los servicios son unidades independientes y aut\u00f3nomas de software, cada una dise\u00f1ada para ejecutar una funci\u00f3n espec\u00edfica dentro de la DSA. Cada servicio se enfoca en una tarea particular del negocio, siguiendo principios clave como alta cohesi\u00f3n (responsabilidad bien definida) y bajo acoplamiento (interacci\u00f3n m\u00ednima con otros servicios). Los servicios est\u00e1n dise\u00f1ados para ser escalables, independientes y f\u00e1cilmente reemplazables, lo que facilita la evoluci\u00f3n de la arquitectura sin afectar el sistema global.</p>"},{"location":"doctecnica/componentes.html#adaptadores","title":"Adaptadores","text":"<p>Los adaptadores son componentes especializados en gestionar la comunicaci\u00f3n entre la DSA y tecnolog\u00edas o sistemas externos, como APIs de terceros, bases de datos, servicios de mensajer\u00eda o sistemas legados. Funcionan como una capa intermedia, que abstrae y encapsula la l\u00f3gica necesaria para interactuar con estos sistemas, proporcionando una interfaz est\u00e1ndar y desacoplada para el resto de los componentes internos. Los adaptadores son esenciales para garantizar que las integraciones externas no afecten directamente a los servicios internos, permitiendo una mayor flexibilidad y mantenibilidad del sistema.</p>"},{"location":"doctecnica/componentes.html#librerias","title":"Librer\u00edas","text":"<p>La librer\u00eda es una colecci\u00f3n de funciones, clases o recursos predefinidos que proporcionan funcionalidades espec\u00edficas y son transversales al funcionamiento de los servicios y adaptadores dentro de la DSA. Los m\u00f3dulos est\u00e1n dise\u00f1ados para ser reutilizables y encapsulan comportamientos comunes que pueden ser utilizados por diferentes componentes, asegurando consistencia y reduciendo la duplicaci\u00f3n de c\u00f3digo en toda la arquitectura.</p>"},{"location":"doctecnica/componentes.html#esquema-de-la-dsa","title":"Esquema de la DSA","text":"<p>La Arquitectura de Servicios de Dominio (DSA) se segmenta en dos grupos principales: uno ubicado en el lado de las terminales (DSA-INTERNA) y otro en las plataformas externas a las terminales (DSA-EXTERNA). La principal diferencia entre estos grupos radica en el comportamiento de sus componentes, determinado por la naturaleza del entorno en el que operan.</p> <p>Por ejemplo:</p> <ul> <li>En las terminales, los flujos de trabajo son sincr\u00f3nicos y se basan en una \u00fanica petici\u00f3n por operaci\u00f3n.</li> <li>En las plataformas externas, los flujos son predominantemente as\u00edncronos y manejan m\u00faltiples peticiones simult\u00e1neamente.</li> </ul> <p>Estas diferencias llevan a que los componentes de ambos lados, aunque compartan un prop\u00f3sito com\u00fan, sean dise\u00f1ados, configurados y desplegados teniendo en cuenta las particularidades de su entorno. Esto asegura que cada grupo de componentes funcione de manera \u00f3ptima dentro de su contexto espec\u00edfico.</p>"},{"location":"doctecnica/componentes.html#dsa-interna","title":"DSA Interna","text":"DIAGRAMA C4 DSA-INTERNA Detalle DSA-INTERNA <p>Esta capa de la DSA es la encargada de la recolecci\u00f3n y normalizaci\u00f3n de las peticiones que llegan del lado del sistema POS cliente, interactuando con componentes de terceros y usuarios para la creaci\u00f3n de la petici\u00f3n que sera enviada a la capa superior.</p>"},{"location":"doctecnica/componentes.html#detalle-de-la-dsa-interna","title":"Detalle de la DSA Interna","text":"<p>La DSA interna est\u00e1 conformada por los siguientes componentes:</p>"},{"location":"doctecnica/componentes.html#adaptadores_1","title":"Adaptadores","text":"<ul> <li>JBAdapter: Componente de tipo adaptador encargado de interpretar y traducir las peticiones y las respuestas entre la DSA y el POS Cliente.</li> </ul> Detalle interno JBAdapter <ul> <li>POSAdapter: Componente de tipo adaptador-librer\u00eda que provee m\u00e9todos para interactuar con el cliente POS.</li> </ul>"},{"location":"doctecnica/componentes.html#servicios_1","title":"Servicios","text":"<ul> <li>Terminal Gateway Service: Encargado de enrutar las solicitudes entre los componentes DSA ubicados en el lado de la terminal y realizar peticiones a componentes por fuera de la misma.</li> </ul> Detalle interno TerminalGatewayService <ul> <li>Data Collector Service: Responsable de recolectar informaci\u00f3n complementaria, normalizar los paquetes de datos para continuar con las operaciones, y validar la informaci\u00f3n recibida.  </li> </ul> Detalle interno DataCollectorService <ul> <li>Parameters Local Storage Service: Persiste localmente las configuraciones obtenidas desde el almac\u00e9n principal, garantizando la disponibilidad de los par\u00e1metros requeridos.</li> </ul> Detalle interno ParametersLocalStorageService"},{"location":"doctecnica/componentes.html#librerias_1","title":"Librer\u00edas","text":"<ul> <li>Data Catalog Library: Librer\u00eda que contiene estructuras, entidades y datos transversales a toda la arquitectura, proporcionando un marco com\u00fan para los distintos componentes.</li> </ul>"},{"location":"doctecnica/documentacion.html","title":"Documentaci\u00f3n","text":"<p>La Arquitectura de Servicios de Dominio (DSA) es un modelo estructurado de componentes interrelacionados que sigue los principios de arquitectura limpia basada en microservicios. Su prop\u00f3sito principal es integrar servicios complementarios a la operaci\u00f3n central del negocio, promoviendo un bajo acoplamiento y una alta cohesi\u00f3n entre ellos.</p> <p>Surge como respuesta a la necesidad de reestructurar los componentes previamente organizados bajo un modelo monol\u00edtico, que dificultaba el mantenimiento y la integraci\u00f3n de nuevas funcionalidades, generando retrasos en los tiempos de desarrollo e inconsistencias de funcionamiento en producci\u00f3n.</p> <p>La DSA define una base estructurada para el desarrollo e integraci\u00f3n de funcionalidades complementarias, gui\u00e1ndose por las siguientes directrices:</p> <ol> <li>Alta cohesi\u00f3n: Cada componente o m\u00f3dulo debe estar especializado en una \u00fanica funcionalidad espec\u00edfica del negocio.</li> <li>Bajo acoplamiento: Los componentes deben comunicarse mediante un mecanismo est\u00e1ndar, garantizando relaciones agn\u00f3sticas entre ellos.</li> <li>Multientorno: Siempre que sea posible, los componentes deben tener capacidades de despliegue en m\u00faltiples backends.</li> <li>Orientaci\u00f3n a la configuraci\u00f3n: Estandarizar la integraci\u00f3n para facilitar la incorporaci\u00f3n de nuevos servicios.</li> <li>Autonom\u00eda: Minimizar la interacci\u00f3n al intercambio esencial de mensajes, asegurando la independencia de cada servicio.</li> <li>Independencia tecnol\u00f3gica: Reducir al m\u00ednimo la dependencia de tecnolog\u00edas externas o servicios fuera del core del negocio.</li> <li>Principios de desarrollo: Implementar y observar principios como SOLID, KISS y DRY, junto con las buenas pr\u00e1cticas de CLEAN CODE.</li> <li>Flexibilidad: Dar prioridad a la adaptabilidad por encima de dogmas estrictos.</li> <li>Pruebas unitarias: Garantizar la calidad del c\u00f3digo mediante pruebas automatizadas.</li> <li>Documentaci\u00f3n t\u00e9cnica: Asegurar que todos los servicios est\u00e9n bien documentados.</li> <li>Cultura de desarrollo: Promover disciplina y buenas pr\u00e1cticas frente a la improvisaci\u00f3n o informalidad.</li> </ol> <p>Estas directrices aseguran que la DSA sea una arquitectura robusta, escalable y alineada con las necesidades del negocio.</p> <p>Otra gran ventaja de la arquitectura es que, aunque en sus bases se construye con lenguaje JAVA, es susceptible de interactuar con componentes escritos en otros lenguajes siempre y cuando se respeten los contratos entre las API's.</p>"},{"location":"doctecnica/estructura-carpetas.html","title":"Estructura de carpetas","text":"<p>El esquema de carpetas utilizado por los componentes de la DSA se fundamenta principalmente en la Arquitectura Hexagonal, con el objetivo de garantizar una separaci\u00f3n clara de responsabilidades. Esto facilita el mantenimiento, la evoluci\u00f3n y la comprensi\u00f3n del c\u00f3digo. El orden y la organizaci\u00f3n se alinean con principios de dise\u00f1o como la inversi\u00f3n de dependencias y el aislamiento de los detalles de implementaci\u00f3n respecto al n\u00facleo de la aplicaci\u00f3n. Es asi que podr\u00edamos enumerar los beneficios clave del esquema como:</p> <ol> <li> <p>Responsabilidad bien definida por capa:    Cada capa del sistema tiene un prop\u00f3sito espec\u00edfico, lo que mejora la claridad y la estructura.</p> </li> <li> <p>Evita dependencias circulares o acoplamiento excesivo:    Se minimizan las relaciones innecesarias entre m\u00f3dulos, manteniendo la flexibilidad y modularidad.</p> </li> <li> <p>Aislamiento del n\u00facleo del dominio:    El n\u00facleo de reglas de negocio permanece independiente de frameworks, bibliotecas externas o tecnolog\u00edas espec\u00edficas.</p> </li> <li> <p>Facilidad de evoluci\u00f3n y reemplazo:    Los componentes pueden ser modificados o sustituidos sin impactar negativamente otras partes de la aplicaci\u00f3n.</p> </li> <li> <p>Mejora en las pruebas:    La separaci\u00f3n clara facilita la escritura de pruebas unitarias e integraci\u00f3n, reduciendo la complejidad de las mismas.</p> </li> <li> <p>Organizaci\u00f3n intuitiva:    Estructura los elementos de manera que los desarrolladores puedan navegar f\u00e1cilmente y ubicar lo que necesitan con rapidez.</p> </li> </ol> Estructura de carpetas<pre><code>\u2500\u2500src\n    \u251c\u2500\u2500main\n    \u2502   \u251c\u2500\u2500java\n    \u2502   \u2502   \u2514\u2500\u2500com\n    \u2502   \u2502       \u2514\u2500\u2500lds\n    \u2502   \u2502           \u2514\u2500\u2500exito\n    \u2502   \u2502               \u2514\u2500\u2500domainservices\n    \u2502   \u2502                   \u2514\u2500\u2500parameterslocalstorageservice\n    \u2502   \u2502                       \u251c\u2500\u2500application\n    \u2502   \u2502                       \u2502   \u251c\u2500\u2500exceptions\n    \u2502   \u2502                       \u2502   \u251c\u2500\u2500pipeline\n    \u2502   \u2502                       \u2502   \u2502   \u2514\u2500\u2500stages\n    \u2502   \u2502                       \u2502   \u2514\u2500\u2500usecases\n    \u2502   \u2502                       \u251c\u2500\u2500domain\n    \u2502   \u2502                       \u2502   \u251c\u2500\u2500dictionaries\n    \u2502   \u2502                       \u2502   \u251c\u2500\u2500exceptions\n    \u2502   \u2502                       \u2502   \u251c\u2500\u2500models\n    \u2502   \u2502                       \u2502   \u2514\u2500\u2500ports\n    \u2502   \u2502                       \u2502       \u251c\u2500\u2500input\n    \u2502   \u2502                       \u2502       \u2514\u2500\u2500output\n    \u2502   \u2502                       \u251c\u2500\u2500infrastructure\n    \u2502   \u2502                       \u2502   \u251c\u2500\u2500adapters\n    \u2502   \u2502                       \u2502   \u2502   \u251c\u2500\u2500input\n    \u2502   \u2502                       \u2502   \u2502   \u2514\u2500\u2500output\n    \u2502   \u2502                       \u2502   \u251c\u2500\u2500configuration\n    \u2502   \u2502                       \u2502   \u2514\u2500\u2500exceptions\n    \u2502   \u2502                       \u2514\u2500\u2500utils\n    \u2502   \u2514\u2500\u2500resources\n    \u2514\u2500\u2500test\n        \u2514\u2500\u2500...\n</code></pre> <p>En el anterior gr\u00e1fico se muestra la estructura est\u00e1ndar de carpetas que se crea mediante el arquetipo <code>base-services-dsa-archetype</code>. A continuaci\u00f3n se detallan su estructura:</p> <p>GroupId: El orden de carpetas inicial para todos los proyectos debe seguir la estructura: <code>src\\main\\java\\com\\lds\\exito\\domainservices\\nombre-del-componente</code>. Al nombrar un nuevo componente, es importante agregar un sufijo que indique su prop\u00f3sito, como <code>service</code> (para servicios) o <code>adapter</code> (para adaptadores). Esto proporciona un contexto m\u00e1s claro sobre la funci\u00f3n del componente al equipo de desarrollo.</p> <p>Carpeta de pruebas unitarias: Los tests del proyecto se ubican en <code>\\src\\test</code>, siguiendo el mismo esquema definido en el <code>groupId</code>.</p> <p>Application: Esta carpeta contiene los componentes responsables de orquestar la l\u00f3gica del dominio. Se encargan de interactuar con los casos de uso, procesar entradas y salidas, y coordinar la interacci\u00f3n entre el dominio y los adaptadores. Esta capa act\u00faa como intermediaria entre el dominio (entidades y l\u00f3gica de negocio) y los puertos de entrada y salida.</p> <ol> <li>usecases: Incluye los casos de uso del componente y las excepciones de la capa, las cuales se manejan y env\u00edan al <code>ControllerAdviser</code>.</li> <li>pipeline: Contiene las clases e interfaces necesarias para implementar el patr\u00f3n Pipeline.</li> </ol> <p>Domain: Esta capa alberga los modelos, clases de valor y puertos, proporcionando una conectividad agn\u00f3stica con las capas externas.</p> <ol> <li>dictionaries: Contiene datos constantes y enumeraciones utilizadas en el programa.</li> <li>models: Incluye la clase <code>Message</code>, que extiende de la superclase <code>BaseMessage</code>, adem\u00e1s de otras clases o entidades requeridas para la operaci\u00f3n del componente.</li> <li>ports: Contiene las interfaces que act\u00faan como puertos de entrada y salida para la comunicaci\u00f3n con los adaptadores.</li> </ol> <p>Infrastructure: Esta capa agrupa los elementos relacionados con la implementaci\u00f3n de los puertos de salida y las adaptaciones a tecnolog\u00edas externas, como bases de datos, servicios de terceros, sistemas de mensajer\u00eda o interfaces de usuario. Se comunica con el dominio mediante interfaces (puertos) y proporciona implementaciones concretas para estos, adapt\u00e1ndose a las infraestructuras tecnol\u00f3gicas requeridas.</p> <ol> <li>adapters: Contiene las implementaciones espec\u00edficas de los puertos de entrada y salida.</li> <li>configuration: Incluye configuraciones globales del proyecto, como <code>beans</code> o el <code>ControllerAdviser</code>.</li> </ol> <p>Resources: Agrupa los archivos <code>.properties</code> necesarios para la configuraci\u00f3n externa del proyecto.</p>"},{"location":"doctecnica/excepciones.html","title":"Manejo de excepciones","text":"<p>El manejo de excepciones es una pr\u00e1ctica clave en el desarrollo de software que permite garantizar la estabilidad, legibilidad y mantenibilidad de las aplicaciones frente a errores o situaciones inesperadas. A continuaci\u00f3n, se detalla su importancia y consideraciones clave dentro de la DSA:</p>"},{"location":"doctecnica/excepciones.html#para-que-sirve-el-manejo-de-excepciones","title":"\u00bfPara qu\u00e9 sirve el manejo de excepciones?","text":"<p>Prevenci\u00f3n de fallos cr\u00edticos:</p> <ul> <li>Permite capturar errores en tiempo de ejecuci\u00f3n antes de que generen interrupciones graves en el sistema.</li> <li>Ayuda a evitar la ca\u00edda completa de la aplicaci\u00f3n, permitiendo una recuperaci\u00f3n controlada.</li> </ul> <p>Mejora de la experiencia del usuario:</p> <ul> <li>Proporciona mensajes claros y \u00fatiles cuando ocurre un error, evitando que el usuario reciba informaci\u00f3n t\u00e9cnica confusa o sin sentido.</li> </ul> <p>Facilita la depuraci\u00f3n:</p> <ul> <li>Al registrar o capturar informaci\u00f3n relevante sobre las excepciones, los desarrolladores pueden analizar y resolver los problemas de manera m\u00e1s eficiente.</li> </ul> <p>Modularidad y robustez:</p> <ul> <li>Ayuda a encapsular errores dentro de m\u00f3dulos espec\u00edficos, reduciendo el impacto en otras partes del sistema.</li> </ul> <p>Cumplimiento de flujos de negocio:</p> <ul> <li>Garantiza que los procesos cr\u00edticos sigan un comportamiento predecible, incluso en situaciones excepcionales.</li> </ul>"},{"location":"doctecnica/excepciones.html#flujos-esperados","title":"Flujos Esperados","text":"<p>Dentro de cualquier arquitectura o sistema, los flujos operativos suelen responder a uno de tres escenarios principales:  </p>"},{"location":"doctecnica/excepciones.html#happy-path-camino-feliz","title":"Happy Path (Camino Feliz)","text":"<p>Es el flujo ideal, donde todo funciona correctamente y el sistema cumple su objetivo de manera esperada. Los datos son v\u00e1lidos, las reglas de negocio se respetan y no se presentan problemas t\u00e9cnicos. Este es el flujo que normalmente se dise\u00f1a y prueba primero, ya que refleja el comportamiento est\u00e1ndar del sistema bajo condiciones \u00f3ptimas.  </p>"},{"location":"doctecnica/excepciones.html#violacion-de-reglas-de-negocio-o-usuario","title":"Violaci\u00f3n de Reglas de Negocio o Usuario","text":"<p>Se produce cuando se infringen las reglas establecidas en el dominio del negocio o las pol\u00edticas del sistema. Estas situaciones est\u00e1n dentro de los escenarios esperados y, por lo tanto, son manejadas expl\u00edcitamente en los flujos del sistema.</p> <p>Ejemplos comunes incluyen un usuario intenta realizar una acci\u00f3n para la cual no tiene permisos o el env\u00edo de datos que no cumplen con las validaciones definidas (e.g., campos obligatorios vac\u00edos, formatos incorrectos).  </p> <p>En estos casos, el sistema responde con mensajes claros que informan al usuario sobre la regla violada y c\u00f3mo puede corregir el error. No se consideran excepciones t\u00e9cnicas, ya que forman parte de las reglas previstas del sistema y est\u00e1n dise\u00f1adas para manejarse sin interrupciones cr\u00edticas.  </p>"},{"location":"doctecnica/excepciones.html#excepcion-tecnica-o-de-codigo","title":"Excepci\u00f3n T\u00e9cnica o de C\u00f3digo","text":"<ul> <li>Este escenario representa fallos imprevistos en el sistema causados por problemas t\u00e9cnicos. Las excepciones t\u00e9cnicas son errores no deseados que est\u00e1n fuera del control directo del sistema o del usuario.  </li> <li>Ejemplos incluyen:</li> <li>Errores de conexi\u00f3n con una base de datos.  </li> <li>Nulidad de un objeto no controlada (e.g., <code>NullPointerException</code> en Java).  </li> <li>Tiempo de espera agotado al consumir un servicio externo.  </li> <li>Estas situaciones deben capturarse mediante mecanismos de manejo de excepciones para evitar ca\u00eddas abruptas del sistema. Esto permite:</li> <li>Implementar una recuperaci\u00f3n controlada.  </li> <li>Notificar adecuadamente al usuario o al equipo t\u00e9cnico.  </li> </ul> <p>Por lo anterior es crucial diferenciar el tratamiento de los flujos no-happy path, ya que lanzar excepciones indiscriminadamente puede ser perjudicial para el sistema. Cuando se lanza una excepci\u00f3n, el sistema debe recolectar informaci\u00f3n para construir la pila de errores (stack trace), lo que implica un consumo considerable de recursos. Adem\u00e1s, las excepciones interrumpen abruptamente el flujo de ejecuci\u00f3n, lo que puede tener consecuencias no deseadas en sistemas complejos o distribuidos.  </p>"},{"location":"doctecnica/excepciones.html#manejo-de-excepciones-en-la-dsa","title":"Manejo de Excepciones en la DSA","text":"<p>Cada capa principal de la DSA tiene su excepci\u00f3n declarada en su carpeta <code>exceptions</code>. Es asi que encontraremos tres clases llamadas <code>DomainException</code>, <code>ApplicationException</code> e <code>InfrastructureException</code>. Estas clase extienden una superclase abstracta llamada <code>BaseException</code> que provee dos constructores base: <code>BaseException(String message)</code> y <code>BaseException(String message, Throwable cause)</code>.</p> <p>En el caso de <code>ApplicationException</code> tiene un atributo del tipo <code>BaseMessage</code> que se inicializa en su constructor <code>ApplicationException(String message, BaseMessage baseMessage)</code> y ademas provee un m\u00e9todo llamado <code>getBaseMessage()</code>. Esto con el fin de darle manejo a las excepciones lanzadas desde otros servicios y poder transportar el problema ra\u00edz hasta el sistema cliente.</p> <p>Dado que estas excepciones son t\u00e9cnicas y no deben ser visibles en detalle para el sistema cliente pero si para el equipo t\u00e9cnico interno, estas se lanzan acompa\u00f1adas de un registro de logging basado en <code>SLF4J</code> para almacenar informaci\u00f3n detallada sobre las excepciones. Esto es crucial para la trazabilidad y el diagn\u00f3stico.</p> <p>El siguiente es un ejemplo del uso de excepciones de la DSA:</p> Bloque ejemplo de manejo de errores<pre><code>...\ncatch (ResourceAccessException ex) {\n\n    log.error(LogMessage.create(\n        traceId, \n        TGS001.getError(), \n        TGS001.getDescription(), \n        ex.getMessage()) \n        );\n\n    throw new InfrastructureException(TGS001.getError()); \n    // Excepci\u00f3n de la capa de infraestructura\n\n}\n</code></pre> <p>N\u00f3tese que el uso de las excepciones debe ir acompa\u00f1ado de su respectivo registro en los logs. Esto es fundamental, ya que, aunque las excepciones permiten gestionar errores de ejecuci\u00f3n y notificarlos al sistema cliente, este no debe exponer detalles t\u00e9cnicos sensibles al usuario final. La responsabilidad de capturar y almacenar dicha informaci\u00f3n recae en la trazabilidad operativa, que, mediante un proceso paralelo, se encarga de registrar los detalles relevantes para el diagn\u00f3stico y la soluci\u00f3n del problema.</p> Respuesta de error al cliente<pre><code>{\n    \"operationType\": \"SELL\",\n    \"subOperationType\": \"SUBSCRIPTION\",\n    \"traceId\": \"fb4bbc82-beef-43dc-9f34-4d858cd52c99\",\n    \"messageStatus\": \"ERROR\",\n    \"dataSection\": {\n        \"sections\": {\n            \"errorMessage\": \"TGS001: SERVICIO NO DISPONIBLE\"\n        }\n    }\n}\n</code></pre> Registro en logs del error<pre><code>2024-12-11 09:35:52.745 [http-nio-8080-exec-2] \nERROR [DataCollectorAdapter.java:84] \n- [TraceId: fb4bbc82-beef-43dc-9f34-4d858cd52c99 \n- Error: TGS001: SERVICIO NO DISPONIBLE \n- Descripci\u00f3n: Servicio Data Collector no disponible \n- Detalle: I/O error on POST request for \"http://localhost:8081/api/v1/\": \nConnect to localhost:8081 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1]]\n</code></pre> <p>para complementar el tema, revise el capitulo de  trazabilidad operativa</p>"},{"location":"doctecnica/excepciones.html#que-se-debe-tener-en-cuenta-al-manejar-excepciones","title":"\u00bfQu\u00e9 se debe tener en cuenta al manejar excepciones?","text":"<p>Evitar capturar excepciones gen\u00e9ricas innecesariamente:</p> <ul> <li>Utilizar excepciones espec\u00edficas en lugar de capturar <code>Exception</code> o <code>Throwable</code>, ya que esto puede ocultar errores importantes.</li> </ul> <p>Mantener mensajes claros y significativos:</p> <ul> <li>Al lanzar excepciones, asegurarse de incluir informaci\u00f3n relevante sobre el problema para facilitar la resoluci\u00f3n.</li> </ul> <p>No abusar de excepciones para flujos normales:</p> <ul> <li>Las excepciones son para situaciones inesperadas, no para manejar condiciones regulares de negocio.</li> </ul> <p>Usar bloques <code>try-catch</code> de forma espec\u00edfica:</p> <ul> <li>Limitar los bloques <code>try-catch</code> al c\u00f3digo donde realmente puede ocurrir una excepci\u00f3n. Esto facilita la lectura y evita capturas innecesarias.</li> </ul> <p>Registrar las excepciones (Logging):</p> <ul> <li>Utiliza herramientas de registro para almacenar informaci\u00f3n sobre las excepciones.</li> </ul> <p>No suprimir excepciones sin manejarlas:</p> <ul> <li>Si se captura una excepci\u00f3n, asegurarse de manejarla adecuadamente o relanzarla si no se puede resolverla en el contexto actual.</li> </ul> <p>Definir excepciones personalizadas:</p> <ul> <li>Para contextos espec\u00edficos del negocio, crear excepciones propias que representen claramente el error y su impacto.</li> </ul> <p>Limpieza de recursos:</p> <ul> <li>Asegurarse de cerrar conexiones, liberar memoria o manejar recursos en un bloque <code>finally</code> o utilizando estructuras como <code>try-with-resources</code>.</li> </ul>"},{"location":"doctecnica/mensaje.html","title":"Introducci\u00f3n","text":"<p>Para el intercambio de informaci\u00f3n entre componentes internos y externos, se dise\u00f1\u00f3 un objeto de valor denominado <code>BaseMessage</code>. Su prop\u00f3sito es proporcionar un <code>wrapper</code> de datos consistente y transversal para toda la informaci\u00f3n que circula dentro de la arquitectura. A continuaci\u00f3n, se detalla su estructura y uso:</p>"},{"location":"doctecnica/mensaje.html#cabecera-o-header","title":"Cabecera o Header","text":"<p>La cabecera (header) del mensaje consta de cuatro elementos:</p>"},{"location":"doctecnica/mensaje.html#operationtype","title":"OperationType","text":"<p>Define el tipo de operaci\u00f3n al que pertenece el mensaje, clasific\u00e1ndolo en uno de los tres grupos principales: venta, no venta o pago. Es inmutable.</p>"},{"location":"doctecnica/mensaje.html#suboperationtype","title":"SubOperationType","text":"<p>Especifica las operaciones detalladas dentro de cada tipo de operaci\u00f3n. Estas gu\u00edan a la DSA en el flujo a seguir e indican los datos complementarios necesarios para cada caso. Es inmutable.</p>"},{"location":"doctecnica/mensaje.html#traceid","title":"TraceId","text":"<p>Es un identificador \u00fanico utilizado en sistemas distribuidos para rastrear el recorrido de una solicitud a trav\u00e9s de m\u00faltiples servicios o componentes. Su prop\u00f3sito es simplificar el monitoreo y la depuraci\u00f3n en entornos complejos. Este identificador debe generarse al inicio de la solicitud, ya sea por el cliente o por el adaptador de entrada de la arquitectura. Se utiliza el formato est\u00e1ndar UUID (Universally Unique Identifier) para garantizar unicidad y consistencia en el sistema. Es inmutable.</p>"},{"location":"doctecnica/mensaje.html#messagestatus","title":"MessageStatus","text":"<p>Es un enumerador que indica el estado actual del mensaje, con tres posibles valores: <code>OK</code>, <code>NOK</code> y <code>ERROR</code>.</p> <ul> <li>OK: Estado inicial del mensaje al ser creado. Si el flujo no presenta inconvenientes, permanecer\u00e1 en este estado hasta su finalizaci\u00f3n (happy path).</li> </ul> Representaci\u00f3n de un mensaje OK<pre><code>{\n  \"operationType\": \"NOSELL\",\n  \"subOperationType\": \"RECHARGE\",\n  \"traceId\": \"fb4bbc82-beef-43dc-9f34-4d858cd52c99\",\n  \"messageStatus\": \"OK\",\n  \"dataSection\": {\n    \"sections\": {\n      \"payload\": {\n        \"date\": \"20240725\",\n        \"amount\": \"10000\",\n        \"terminalId\": \"0160\",\n        \"storeId\": \"0013\",\n        \"transactionId\": \"0003\",\n        \"plu\": \"115192\",\n        \"cashierId\": \"0000011111\",\n        \"time\": \"144557\",\n        \"customer\": \"\"\n      }\n    }\n  }\n}\n</code></pre> <ul> <li>NOK: Indica una inconsistencia en el flujo debido a una violaci\u00f3n prevista de las reglas de negocio. En este caso, el mensaje es marcado para ser ignorado en los procesos posteriores hasta la conclusi\u00f3n del flujo.</li> </ul> Representaci\u00f3n de un mensaje NOK<pre><code>{\n  \"operationType\": \"SELL\",\n  \"subOperationType\": \"SUBSCRIPTION\",\n  \"traceId\": \"fb4bbc82-beef-43dc-9f34-4d858cd52c99\",\n  \"messageStatus\": \"NOK\",\n  \"dataSection\": {\n    \"sections\": {\n      \"errorMessage\": \"PLS002: ERROR DEL PROCESO\"\n    }\n  }\n}\n</code></pre> <ul> <li>ERROR: Representa una condici\u00f3n t\u00e9cnica inesperada, como una excepci\u00f3n. Este estado provoca que el flujo sea interrumpido, y el error es devuelto como una <code>Exception</code> mediante la clase <code>GlobalControllerAdvice</code>.</li> </ul> Representaci\u00f3n de un mensaje ERROR<pre><code>{\n  \"operationType\": \"SELL\",\n  \"subOperationType\": \"SUBSCRIPTION\",\n  \"traceId\": \"fb4bbc82-beef-43dc-9f34-4d858cd52c99\",\n  \"messageStatus\": \"ERROR\",\n  \"dataSection\": {\n    \"sections\": {\n      \"errorMessage\": \"DCS001: SERVICIO NO DISPONIBLE\"\n    }\n  }\n}\n</code></pre>"},{"location":"doctecnica/mensaje.html#cuerpo-o-datasection","title":"Cuerpo o DataSection","text":"<p>El <code>DataSection</code> del mensaje es una estructura mutable dise\u00f1ada para transportar la carga \u00fatil de una operaci\u00f3n espec\u00edfica. Su organizaci\u00f3n se basa en secciones con formato clave-valor (<code>Map&lt;String, Object&gt;</code>), lo que permite agregar diferentes tipos de datos, cada uno identificado por una clave \u00fanica. Funciona como un contenedor de informaci\u00f3n que incluye peque\u00f1os contenedores rotulados llamados <code>section</code>, capaces de almacenar tanto objetos espec\u00edficos como otros contenedores.</p> <p>Si observamos el json de la representaci\u00f3n de un mensaje OK, vemos que contiene una secci\u00f3n llamada <code>payload</code> la cual contiene a su vez un conjunto de datos. Esta secci\u00f3n es principal y deber\u00eda contener los datos principales de cualquier petici\u00f3n hecha a la nueva arquitectura exceptuando en los casos donde el mensaje toma el estado <code>NOK</code> o <code>ERROR</code> en cuyo caso la secci\u00f3n se llamar\u00e1 <code>errorMessage</code>.</p> <p>Es crucial gestionar eficientemente el contenido del <code>DataSection</code>, asegurando que los mensajes sean suficientes en t\u00e9rminos de informaci\u00f3n contenida. Esto implica evitar duplicidad de datos, eliminaci\u00f3n de informaci\u00f3n obsoleta para operaciones futuras y reducir el anidamiento innecesario.</p> <p>La clase <code>BaseMessage</code> proporciona m\u00faltiples m\u00e9todos para realizar operaciones CRUD sobre estos contenedores, facilitando su manipulaci\u00f3n y organizaci\u00f3n.</p> <p>Tip</p> <p>En el caso de los adaptadores, el Mensaje como objeto de transporte recibe un tratamiento especial, ya que estos adaptadores, por su naturaleza, deben comunicarse con las capas externas y con terceros en t\u00e9rminos de sus respectivas APIs. Esto ocurre cuando no es posible que dichas capas o sistemas externos se adapten al esquema del Mensaje definido por la DSA. Los adaptadores tienen la responsabilidad de actuar como traductores entre las tecnolog\u00edas externas y la DSA.</p>"},{"location":"doctecnica/mensaje.html#uso-de-la-clase-basemessage","title":"Uso de la clase BaseMessage","text":"<p>La clase <code>BaseMessage</code> se encuentra en la librer\u00eda <code>datacatalog</code>, la cual es importada por todos los proyectos que componen la DSA. Esto garantiza el uso consistente de las mismas entidades y estructuras de datos en todo el flujo de los procesos.</p> <p>Se recomienda extender esta clase en una clase <code>Message</code> dentro de la capa de dominio de los componentes, en lugar de utilizarla directamente. De esta forma, se facilita el manejo de diferentes tipos de mensajes con un n\u00facleo com\u00fan, adaptado seg\u00fan el contexto.</p> <p>La clase <code>BaseMessage</code> dispone de dos constructores: uno vac\u00edo, utilizado para procesos de serializaci\u00f3n/deserializaci\u00f3n, y otro que acepta tres argumentos: <code>operationType</code>, <code>subOperationType</code> y <code>traceId</code>. Al instanciar la clase, su variable <code>messageStatus</code> toma por defecto el valor <code>OK</code>.</p> <p>La clase cuenta con dos m\u00e9todos:</p> <ul> <li><code>setNOKStatus(String message)</code>: Cambia el estado del mensaje para que sea administrado por el flujo como error de regla de negocio.</li> <li><code>setErrorStatus(String message)</code>: Cambia el estado del mensaje para que sea administrado por el flujo de excepciones.</li> </ul> <p>Una vez creado el objeto <code>Message</code>, se debe agregar la <code>dataSection</code>. Esta clase tambi\u00e9n se encuentra en la librer\u00eda <code>datacatalog</code> y contiene un atributo de tipo <code>HashMap&lt;String, Object&gt;</code>. <code>DataSection</code> proporciona un conjunto de m\u00e9todos para su manipulaci\u00f3n:</p> <ul> <li><code>DataSection()</code>: Constructor vac\u00edo que inicializa el atributo <code>HashMap&lt;String, Object&gt;</code>.</li> <li><code>DataSection(String sectionName, Object data)</code>: Constructor con argumentos que inicializa el atributo <code>HashMap&lt;String, Object&gt;</code> y crea una <code>section</code> dentro del mapa.</li> <li><code>addSection(String sectionKey, Object data)</code>: Agrega una <code>section</code> a un <code>dataSection</code> existente.</li> <li><code>getSection(String sectionKey, Class&lt;T&gt; type)</code>: Recupera una <code>section</code> del <code>dataSection</code>, usando la clave y especificando el tipo de retorno esperado.</li> <li><code>getSections()</code>: Recupera todas las <code>sections</code> que contiene el mensaje.</li> <li><code>deleteSection(String sectionKey)</code>: Elimina una <code>section</code> espec\u00edfica.</li> <li><code>deleteAllSections()</code>: Elimina todas las <code>sections</code> del <code>dataSection</code>.</li> <li><code>toString()</code>: Representaci\u00f3n en cadena del objeto.</li> </ul> <p>Warning</p> <p>Se debe tener en cuenta que cualquier cambio realizado en uno de los componentes de la librer\u00eda <code>datacatalog</code> afectar\u00e1 a todos los componentes que la importen. Por lo tanto, es importante realizar ajustes o cambios con cuidado para evitar impactos inesperados en otros m\u00f3dulos que dependan de ella.</p>"},{"location":"doctecnica/patron-pipeline.html","title":"Patr\u00f3n Pipeline","text":"<p>Dentro de la construcci\u00f3n de los componentes se han tenido en cuenta el uso de patrones de dise\u00f1o de software, que permitan orden y escalabilidad. Es asi como dentro de la estructura superior se implementa el patron pipeline. Este patr\u00f3n se utiliza para procesar datos en una serie de etapas o pasos secuenciales, donde el resultado de cada etapa se pasa como entrada a la siguiente.</p>"},{"location":"doctecnica/patron-pipeline.html#concepto-basico","title":"Concepto b\u00e1sico","text":"<p>El patr\u00f3n Pipeline organiza un flujo de trabajo en el que los datos (o eventos) se \"canalizan\" a trav\u00e9s de una serie de \"etapas\" que realizan transformaciones espec\u00edficas. Cada etapa del pipeline procesa los datos y pasa el resultado a la siguiente etapa en la cadena. Este enfoque permite una mayor modularidad y reutilizaci\u00f3n, ya que las etapas pueden ser independientes entre s\u00ed.</p> <p>Sus principales caracter\u00edsticas son la secuencialidad, la transformaci\u00f3n y la modularidad.</p>"},{"location":"doctecnica/patron-pipeline.html#implementacion","title":"Implementaci\u00f3n","text":"<p>La implementaci\u00f3n de este patr\u00f3n se lleva a cabo en la capa application. En la carpeta <code>pipeline</code> se define:</p> <ul> <li>Interfaz Pipe: La interfaz <code>Pipe</code> define un contrato para cada etapa o stage del pipeline, y el m\u00e9todo <code>add</code> permite agregar nuevas etapas, creando un flujo de procesamiento en serie.</li> </ul> Definici\u00f3n del Pipe<pre><code>public interface Pipe&lt;I, O&gt; {\n    // M\u00e9todo que define la transformaci\u00f3n de un tipo de entrada I a un tipo de salida O.\n    O runStage(I inputMessage);\n\n    // M\u00e9todo por defecto para encadenar esta etapa del pipeline con otra.\n    default &lt;N&gt; Pipe&lt;I, N&gt; add(Pipe&lt;O, N&gt; pipe) {\n        // Este m\u00e9todo permite a\u00f1adir una nueva etapa al pipeline, devolviendo una nueva instancia de Pipe\n        // que toma el tipo de entrada I, pasa por esta etapa (runStage) y luego pasa el resultado a la siguiente etapa (pipe.runStage).\n        return inputMessage -&gt; pipe.runStage(runStage(inputMessage));\n    }\n}\n</code></pre> <ul> <li>Etapas (Stages): En la carpeta <code>pipeline/stages</code> se definen las clases correspondientes a cada una de las etapas que se procesar\u00e1n en el flujo del pipeline. Estas clases concretas deben implementar la interfaz <code>Pipe</code>, especificando el tipo de datos que esperan recibir y el tipo de datos que entregar\u00e1n. Act\u00faan como puntos de entrada hacia los casos de uso, desde donde se pueden ramificar hacia otras clases, siempre asegurando que est\u00e9n agrupadas de manera cohesiva. Este enfoque facilita la identificaci\u00f3n de puntos espec\u00edficos dentro del flujo, evitando la creaci\u00f3n de un c\u00f3digo desorganizado o dif\u00edcil de mantener.</li> </ul> Ejemplo de un Stage<pre><code>@Service\n@RequiredArgsConstructor\npublic class DataCollectorStage implements Pipe&lt;Message, Message&gt; {\n\n    private final DataCollectorPort dataCollector;\n\n    @Override\n    public Message runStage(Message inputMessage) {\n\n        if (inputMessage.getMessageStatus() == MessageStatus.NOK)\n            return inputMessage;\n\n        try {\n            return dataCollector.getDataFromCollector(inputMessage);\n        } catch (RuntimeException ex) {\n            throw new ApplicationException(ex.getMessage(), inputMessage);\n        }\n    }\n\n}\n</code></pre> <ul> <li>Pipeline y PipelineImpl: Pipeline es una interfaz que provee un \u00fanico m\u00e9todo de inicializaci\u00f3n del procesos del <code>pipe</code>. Esta interfaz debe ir en la capa de <code>domain</code> idealmente para desacoplar su implementaci\u00f3n de las capas superiores y facilitar las pruebas unitarias.</li> </ul> Ejemplo<pre><code>public interface Pipeline {\n\n    public Message executeMainProcess(Message inputMessage);\n}\n</code></pre> <p>PipelineImpl es la implementaci\u00f3n concreta del puerto Pipeline y en este se definen los <code>stages</code> y el orden de ejecuci\u00f3n de los mismos mediante el m\u00e9todo <code>add</code>.</p> Ejemplo<pre><code>@Slf4j\n@Service\n@RequiredArgsConstructor\npublic class PipelineImpl implements Pipeline {\n\n    // se definen los stages a encadenar\n    private final MessageValidatorStage messageValidatorStage;\n    private final DataCollectorStage dataCollectionStage;\n    private final PostProcessClientStage postProcessClientStage;\n\n    public Message executeMainProcess(Message inputMessage) {\n\n        // se encadenan siguiendo el orden necesario\n        Pipe&lt;Message, Message&gt; pipeline = messageValidatorStage\n                .add(dataCollectionStage)\n                .add(postProcessClientStage);\n\n        // ejecuta los stages de manera secuencial.\n        return pipeline.runStage(inputMessage);\n\n    }\n\n}\n</code></pre> <p>Warning</p> <p>Se debe observar que en la declaraci\u00f3n del <code>Pipe pipeline</code> el tipo de dato de entrada debe corresponder al tipo de entrada del primer stage ejecutado (<code>messageValidatorStage</code>) y el dato de salida debe corresponder al dato de retorno del ultimo stage en la cadena de procesamiento (<code>postProcessClientStage</code>).</p> <p>Como se puede observar, el principal beneficio del patr\u00f3n Pipeline radica en su modularidad y flexibilidad en el procesamiento de datos. Al descomponer un proceso en una serie de etapas (o filtros) independientes, cada una encargada de realizar una transformaci\u00f3n o acci\u00f3n espec\u00edfica, este patr\u00f3n act\u00faa como el n\u00facleo principal de la aplicaci\u00f3n. A partir de \u00e9l, se pueden ramificar procesos especializados que complementen o extiendan una etapa o stage en particular.</p> <p>Sin embargo, aunque el patr\u00f3n Pipeline es altamente efectivo en diversos escenarios, no es adecuado para todos los casos. Algunos ejemplos donde no resulta apropiado son: procesos no secuenciales o dependientes, tareas demasiado simples o triviales, procesos que requieren un estado compartido o transacciones, y procesamiento paralelo no soportado.</p>"},{"location":"doctecnica/trazabilidad.html","title":"Trazabilidad Operativa","text":"<p>La trazabilidad operativa es la capacidad de rastrear y registrar las actividades y eventos que ocurren durante la ejecuci\u00f3n de un sistema o aplicaci\u00f3n. Se enfoca en el seguimiento del flujo de datos, acciones y procesos en tiempo real o en el historial de operaci\u00f3n, con el objetivo de garantizar que el sistema funcione correctamente, identificar problemas y facilitar la auditor\u00eda.</p>"},{"location":"doctecnica/trazabilidad.html#principales-caracteristicas","title":"Principales caracter\u00edsticas","text":"<ul> <li>Monitoreo en tiempo real: Rastrear qu\u00e9 ocurre en el sistema en el momento en que sucede.</li> <li>Registro de eventos: Capturar informaci\u00f3n relevante, como peticiones, respuestas, excepciones, y estados del sistema.</li> <li>Seguimiento de transacciones: Identificar c\u00f3mo una acci\u00f3n espec\u00edfica (como una solicitud de usuario) fluye a trav\u00e9s de diferentes componentes del sistema.</li> <li>Diagn\u00f3stico y resoluci\u00f3n de problemas: Permite identificar la causa ra\u00edz de errores o cuellos de botella en el sistema.</li> <li>Auditor\u00eda y cumplimiento: Mantener un historial de operaciones para cumplir con normativas o revisiones.</li> </ul>"},{"location":"doctecnica/trazabilidad.html#trazabilidad-en-la-dsa","title":"Trazabilidad en la DSA","text":"<p>En la DSA se usa <code>SLF4J</code> (mediante anotaciones de <code>Lombok</code>)  como interfaz y <code>Logback</code> como motor de logging. Esto permite escribir c\u00f3digo desacoplado del framework de logging espec\u00edfico, facilitando la flexibilidad para cambiarlo sin modificar el c\u00f3digo fuente.</p> <p>Con la finalidad de homogenizar la estructura de las trazas de error en los logs, se provee a trav\u00e9s del la librer\u00eda <code>DataCatalogLibrary</code> una clase <code>LogMessage</code> con un \u00fanico m\u00e9todo est\u00e1tico llamado <code>create</code>, el cual recibe como par\u00e1metros 4 argumentos que son:</p> <ul> <li>traceId: el identificador \u00fanico del mensaje que est\u00e1 en la cabecera del mismo.</li> <li>error: El c\u00f3digo de error interno del componente que se haya definido en la clase <code>ErrorCode</code> de la capa <code>domain</code>.</li> <li>description: La descripci\u00f3n asociada al c\u00f3digo de error.</li> <li>detail: El detalle del error lanzado por la excepci\u00f3n (<code>exception.getMessage</code>) o la descripci\u00f3n t\u00e9cnica del desarrollador.</li> </ul> <p>El siguiente es un ejemplo de registro de logging en el c\u00f3digo:</p> Bloque ejemplo de manejo de logging<pre><code>...\ncatch (ResourceAccessException ex) {\n\n    log.error(LogMessage.create(\n        traceId, // el identificador del Message\n        TGS001.getError(), // El c\u00f3digo interno de error\n        TGS001.getDescription(), // description asociada al c\u00f3digo de error\n        ex.getMessage()) // El detalle t\u00e9cnico del error\n        );\n\n    throw new InfrastructureException(TGS001.getError());\n\n}\n</code></pre> <p>N\u00f3tese que el bloque <code>log.error</code> va seguido de un <code>throw</code> que lanza la excepci\u00f3n espec\u00edfica de la capa correspondiente, incluyendo el mismo c\u00f3digo de error utilizado en el log. Esta pr\u00e1ctica se emplea para garantizar que los registros de log sean consistentes con el mensaje enviado al sistema cliente, lo que facilita tanto la identificaci\u00f3n del error como la del servicio donde ocurri\u00f3 el problema.</p> <p>Adem\u00e1s, esta consistencia entre los logs y las excepciones mejora la trazabilidad del sistema, ya que permite correlacionar r\u00e1pidamente los eventos registrados con los errores reportados. Esto resulta clave en entornos distribuidos o con m\u00faltiples servicios, donde la identificaci\u00f3n precisa de la fuente del error es esencial para agilizar el diagn\u00f3stico y la resoluci\u00f3n del incidente.</p> Respuesta de error al cliente<pre><code>{\n    \"operationType\": \"SELL\",\n    \"subOperationType\": \"SUBSCRIPTION\",\n    \"traceId\": \"fb4bbc82-beef-43dc-9f34-4d858cd52c99\",\n    \"messageStatus\": \"ERROR\",\n    \"dataSection\": {\n        \"sections\": {\n            \"errorMessage\": \"TGS001: SERVICIO NO DISPONIBLE\"\n        }\n    }\n}\n</code></pre> Registro en logs del error<pre><code>2024-12-11 09:35:52.745 [http-nio-8080-exec-2] \nERROR [DataCollectorAdapter.java:84] \n- [TraceId: fb4bbc82-beef-43dc-9f34-4d858cd52c99 \n- Error: TGS001: SERVICIO NO DISPONIBLE \n- Descripci\u00f3n: Servicio Data Collector no disponible \n- Detalle: I/O error on POST request for \"http://localhost:8081/api/v1/\": \nConnect to localhost:8081 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1]]\n</code></pre> <p>para complementar el tema, revise el capitulo de  manejo de excepciones</p>"},{"location":"doctecnica/trazabilidad.html#la-clase-errorcode","title":"La clase ErrorCode","text":"<p>Se ha destacado en varias ocasiones la importancia del uso de c\u00f3digos de error internos en cada servicio. En la ubicaci\u00f3n <code>domain/dictionaries</code> se encuentra la clase <code>ErrorCode</code>, que es de tipo <code>Enumerador</code> y tiene la responsabilidad de almacenar los c\u00f3digos de los posibles errores que puedan ocurrir durante la ejecuci\u00f3n del servicio. Esta estructuraci\u00f3n proporciona una manera ordenada y homog\u00e9nea de gestionar los fallos del sistema, permitiendo una comunicaci\u00f3n clara y eficaz de los errores, lo cual facilita la detecci\u00f3n, el diagn\u00f3stico y la resoluci\u00f3n oportuna de los problemas.</p> <p>Adem\u00e1s, el uso de un enumerador para los c\u00f3digos de error asegura consistencia y facilita el mantenimiento del sistema, ya que centraliza la definici\u00f3n de los errores y evita posibles discrepancias o redundancias en diferentes partes del c\u00f3digo.</p> Ejemplo de la clase ErrorCode en Terminal Gateway Service<pre><code>public enum ErrorCode {\n\n    TGS001(\"TGS001: SERVICIO NO DISPONIBLE\", \"Servicio Data Collector no disponible\"),\n    TGS002(\"TGS002: ERROR DEL PROCESO\", \"Respuesta del servicio consultado con novedad\"),\n    TGS003(\"TGS003: ERROR EN LOS PAR\u00c1METROS\", \"El tipo y el subtipo de la operaci\u00f3n no pertenecen al mismo contexto\"),\n    TGS004(\"TGS004: ERROR DEL PROCESO\", \"Fall\u00f3 la deserializaci\u00f3n\"),\n    TGS005(\"TGS005: ERROR DEL PROCESO\", \"Respuesta vac\u00eda\");\n\n    private String error;\n    private String description;\n\n    private ErrorCode(String error, String description) {\n        this.error = error;\n        this.description = description;\n    }\n\n    public String getError() {\n        return error;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n}\n</code></pre> <p>Se recomienda que cada servicio contenga una clase-enumerador de este tipo para guardar consistencia en el manejo de errores a traves de la DSA y evitar descripciones de errores poco detallados, ambiguos o demasiado verbosos.</p>"}]}